/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file PredicateCWSeparableMetric.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2015/04/17
 *
 * Implementation of inline methods defined in PredicateCWSeparableMetric.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------
template <typename T,  typename W, typename P>
inline
DGtal::PredicateCWSeparableMetric<T,W,P>::PredicateCWSeparableMetric()
{
}

//------------------------------------------------------------------------------
template <typename T, typename W, typename P>
inline
DGtal::PredicateCWSeparableMetric<T,W,P>::~PredicateCWSeparableMetric()
{
}
//------------------------------------------------------------------------------
template <typename T, typename W, typename P>
inline
typename DGtal::PredicateCWSeparableMetric<T,W,P>::Promoted
DGtal::PredicateCWSeparableMetric<T,W,P>::DistanceRepresentation (const Point &aP,
										 const Point &aQ) const
{
  // L2 distance
  Promoted res= NumberTraits<Promoted>::ZERO;
  for(DGtal::Dimension d=0; d< Point::dimension ; ++d)
    {
      res += functions::power(static_cast<Promoted>(abs(aP[d]-aQ[d])), 2);
    }
  return res;
}



//------------------------------------------------------------------------------
template <typename T, typename W, typename P>
inline
typename DGtal::PredicateCWSeparableMetric<T,W,P>::Distance
DGtal::PredicateCWSeparableMetric<T,W,P>::restrictedCWDistance (const Point &aP,
						      const Point &aQ,
						      const Weight &aW
						      ) const
{
  if(DistanceRepresentation(aP,aQ) <= aW[0]*aW[0])
    return 0;
  else
    if(DistanceRepresentation(aP,aQ) > aW[1]*aW[1])
      return 1;
    else
  //ASSERT(aW[1] > aW[0]);
      return (sqrt(DistanceRepresentation(aP,aQ)) - aW[0])/(Distance) (aW[1]-aW[0]);
  // if(d > 1)
  //   return 10000;
  // else
  //   if(d < 0)
  //     return 0;
  //   else
  //return d;
      
}


//------------------------------------------------------------------------------
template <typename T, typename W, typename P>
inline
typename DGtal::PredicateCWSeparableMetric<T,W,P>::Distance
DGtal::PredicateCWSeparableMetric<T,W,P>::CWDistance (const Point &aP,
						      const Point &aQ,
						      const Weight &aW
						      ) const
{
  //ASSERT(aW[1] > aW[0]);
  Distance d = (sqrt(DistanceRepresentation(aP,aQ)) - aW[0])/(Distance) (aW[1]-aW[0]);
  // if(d > 1)
  //   return 10000;
  // else
  //   if(d < 0)
  //     return 0;
  //   else
  return d;
      
}
//------------------------------------------------------------------------------

template <typename T, typename W, typename P>
inline
DGtal::Closest
DGtal::PredicateCWSeparableMetric<T,W,P>::closestCW (const Point &origin, 
						   const Point &first,  
						   const Weight &wf,
						   const Point &second,
						   const Weight &ws) const
{
  Distance a,b;
      
  a = CWDistance(origin, first, wf);
  b = CWDistance(origin, second, ws);
  
  if (a<b)
    return ClosestFIRST;
  else
    if (a>b)
      return ClosestSECOND;
    else
      return ClosestBOTH;
}



//------------------------------------------------------------------------------
// locate the voronoi edge between sites and v on the span between lower and upper
template <typename T,  typename W, typename P>
inline
typename DGtal::PredicateCWSeparableMetric<T,W,P>::Abscissa 
  DGtal::PredicateCWSeparableMetric<T,W,P>::binarySearchHidden(const Abscissa &udim, 
							     const Abscissa &vdim,
							     const Promoted &nu,
							     const Weight &wu,
							     const Promoted &nv,
							     const Weight &wv,
							     const Abscissa &lower,
							     const Abscissa &upper) const
  {   
    ASSERT(  (nu +  functions::power( static_cast<Promoted>(abs( udim - lower)), 2)) <
           (nv +  functions::power( static_cast<Promoted>(abs( vdim - lower)), 2)));
  
  //Recurrence stop 
  if ( (upper - lower) <= NumberTraits<Abscissa>::ONE)
    {
      //testing upper
      Promoted nuUpdated = nu +  functions::power( static_cast<Promoted>(abs( udim - upper )), 2);
      Promoted nvUpdated = nv +  functions::power( static_cast<Promoted>(abs( vdim - upper )), 2);
      
      Distance nuReal = (sqrt(nuUpdated) - wu[0])/(Distance) (wu[1]-wu[0]);
      Distance nvReal = (sqrt(nvUpdated) - wv[0])/(Distance) (wv[1]-wv[0]);
      
      std::cout << udim << " " << vdim << " " << lower << " " << upper << std::endl;

      if (nuReal < nvReal)
        return upper;
      else
        return lower;
    }
  
  Abscissa mid = (lower + upper)/2;
  Promoted nuUpdated = nu +  functions::power( static_cast<Promoted>(abs( udim - mid )), 2);
  Promoted nvUpdated = nv +  functions::power( static_cast<Promoted>(abs( vdim - mid )), 2);
  
  Distance nuReal = (sqrt(nuUpdated) - wu[0])/(Distance) (wu[1]-wu[0]);
  Distance nvReal = (sqrt(nvUpdated) - wv[0])/(Distance) (wv[1]-wv[0]);
  //Recursive call
  if ( nuReal < nvReal)
    return binarySearchHidden(udim,vdim,nu,wu,nv,wv,mid,upper);
  else
    return binarySearchHidden(udim,vdim,nu,wu,nv,wv,lower,mid);
}


//------------------------------------------------------------------------------
template <typename T,  typename W, typename P>
inline
bool 
DGtal::PredicateCWSeparableMetric<T,W,P>::hiddenByCW(const Point &u, 
						      const Weight &wu,
						      const Point &v,
						      const Weight &wv,
						      const Point &w, 
						      const Weight &ww,
						      const Point &startingPoint,
						      const Point &endPoint,
						      const typename Point::UnsignedComponent dim) const
{
  //Interval bound for the binary search
  Abscissa lower = startingPoint[dim];
  Abscissa upper = endPoint[dim];
  
  std::cout << u << " " << v << " " << w << " " << lower << " " << upper << std::endl;

  //Partial norm computation
  // (sum_{i!=dim}  |u_i-v_i|^p
  Promoted nu = 0;
  Promoted nv = 0;
  Promoted nw = 0;
  // Promoted nu = -wu;
  // Promoted nv = -wv;
  // Promoted nw = -ww;
  
  //same partial norm sum{i!=dim} |u_i-v_i|^p for all the points of the span (only the dim coordinate changes)
  for(DGtal::Dimension i  = 0 ; i < Point::dimension ; i++)
    if (i != dim)
      {
        nu += functions::power ( static_cast<Promoted>(abs(u[i] - startingPoint[i])), 2);
        nv += functions::power ( static_cast<Promoted>(abs(v[i] - startingPoint[i])), 2);
        nw += functions::power ( static_cast<Promoted>(abs(w[i] - startingPoint[i])), 2);
      }

  //Abscissa of voronoi edges
  Abscissa uv,vw;
  Promoted dv,dw,du,ddv,ddw;
   
  //checking distances to lower bound

  du = nu + functions::power(static_cast<Promoted>(abs(u[dim] - lower)), 2);
  dv = nv + functions::power(static_cast<Promoted>(abs(v[dim] - lower)), 2);
  dw = nw + functions::power(static_cast<Promoted>(abs(w[dim] - lower)), 2);
  
    
  // Compute "true" distance defore any comparison
  Distance ru = (sqrt(du)-wu[0])/(Distance) (wu[1]-wu[0]);
  Distance rv = (sqrt(dv)-wv[0])/(Distance) (wv[1]-wv[0]);
  Distance rw = (sqrt(dw)-ww[0])/(Distance) (ww[1]-ww[0]);
    
  //Precondition of binarySearchHidden is true
  if (ru < rv )
    {
      uv = binarySearchHidden(u[dim],v[dim],nu,wu,nv,wv,lower,upper);
      if (rv < rw)
        {
          vw = binarySearchHidden(v[dim],w[dim],nv,wv,nw,ww,lower,upper); //precondition
          return (uv > vw);
        }

      if (rw > rv)
        return true; 
      else
        {
          //check if uv + 1 is stricly in W
       
          //first, optimisation
          if (uv == upper) return true;
          
          //distances at uv+1
          ddv = nv + functions::power( static_cast<Promoted>(abs( v[dim] - uv -1)), 2);
          ddw = nw + functions::power( static_cast<Promoted>(abs( w[dim] - uv -1)), 2);
          Distance rrv = (sqrt(ddv)-wv[0])/(Distance) (wv[1]-wv[0]);
	  Distance rrw = (sqrt(ddw)-ww[0])/(Distance) (ww[1]-ww[0]);
	  if (rrw < rrv)
            return true;
          else
            return false;
        }
    }
  else  // du >= dv
    {
      if (rv <= rw)
        return false;
      else
        return true;
    }
}



///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename T, typename W, typename P>
inline
void
DGtal::PredicateCWSeparableMetric<T,W,P>::selfDisplay ( std::ostream & out ) const
{
  out << "[PredicateCWSeparableMetric]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename T, typename W, typename P>
inline
bool
DGtal::PredicateCWSeparableMetric<T,W,P>::isValid() const
{
    return true;
}




