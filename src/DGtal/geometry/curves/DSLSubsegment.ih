/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DSLSubsegment.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2012/07/17
 *
 * Implementation of inline methods defined in DSLSubsegment.h
 *
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

//#define DEBUG

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC()
{}

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC(const Integer x0, const Integer y0)
{
  x = x0;
  y = y0;
} 

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC(const Integer p , const Integer q, const Integer r, const Integer slope)
{
  x = slope;
  y = (r+p*x)/q;
}

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::~RayC()
{
}


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::min (Integer a, Integer b)
{
  if(a<b)
    return a;
  else 
    return b;
}

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersectionVertical(Point P, Vector v, Integer n)
{
  if(v[0] == 0)
    return n;
  else
    {
      Integer val = (n-P[0])/v[0];
      if(((n-P[0])<0 || v[0] <0) && !((n-P[0])<0 && v[0] <0))
	val--;
      
      return val;
      //return (Integer) floor((FloatType) (n-P[0])/v[0]);
    }
} 





// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersection(Point P, Vector v, Vector aL)
// {
//   if(v[0]==0)
//     {
//       return (Integer) floor((FloatType) (aL[1]*P[0] - aL[0]*P[1])/(v[1]*aL[1]));
//     }
//   else
//     //if(v[0] != 0)
//     {
//       Number num = -P[1]*aL[0]*v[0] - P[0]*(v[1]*aL[0] - aL[1]*v[0]) + aL[0]*v[1]*P[0];
//       Number denom = v[0]*(v[1]*aL[0] - aL[1]*v[0]);
//       return (Integer) floor((FloatType) num/denom);
//     }
// }


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersection(Point P, Vector v, Vector aL, Integer r)
{ 
  Number num = P[1]*aL[0]-aL[1]*P[0]-r;
  Number denom = aL[1]*v[0]-v[1]*aL[0];
  // using parametric definition of lines and solving for t -> not more precise than the other computation...
  //  std::cout << num << " " << denom << std::endl;
  
  //std::cout << v << " " << aL << std::endl;

  // if(num==denom)
  //   return 1;
  // else
  Integer val = num/denom;

  // integer rounding is not equivalent to the floor operation when num/denom is negative
  if((num<0 ||denom <0) && !(num<0 && denom <0))
    val--;
  
  // Integer val = (Integer) floor((FloatType) num/denom);
  
  // assert (val == val2);
  
  return val;
 // std::cout << num << " " << denom << " " << val << std::endl;
  
  // // if(num<denom)
  // //   return 0;
  // // else
  // {
  //     lldiv_t divresult;
  //     divresult = lldiv(num,denom);
  //     std::cout << divresult.quot <<std::endl;
  //     return divresult.quot;
  //   }
  
}




template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersection(Point P, Vector v, Number s)
{
  // vector to be approximated = (1,s)
  
  if(v[0]==0)
    {
      Number val = (s*P[0] - P[1])/(v[1]*s);
      if(ceil(val)-val <= myPrecision) // val is very close and slightly under an integer -> consider that it is equal to the integer
	return (Integer) ceil(val);
      else
	return (Integer) floor(val);
    }
  else
    {
      //std::cout << "intersection P, V and slope " << P << " " << v << " " << s << std::endl;
      Number num = -P[1]*v[0] - P[0]*(v[1] - s*v[0]) + v[1]*P[0];
      Number denom = v[0]*(v[1] - s*v[0]);
      Number val = num/denom;
      
      Number val2 = (P[1]-s*P[0])/(s*v[0]-v[1]); // using parametric definition of lines and solving for t -> not more precise than the other computation...
      
      Number val3;
      PointF Q;
      Q[0] = P[0] + ceil(val)*v[0];
      Q[1] = P[1] + ceil(val)*v[1];
      
      val3 = (Number) Q[0]*s - (Number) Q[1];
      
      //std::cout << Q << std::endl;
      //std::cout << std::setprecision(15) << "val 3 = " << Q[0]*s - Q[1] << std::endl;
      
      //std::cout << std::setprecision(15) << "intersection " << num << " " << denom << " " << val << " " << val2 << std::endl;
      
      if(fabs(val3) <= myPrecision)
	{
	  //std::cout << " ceil " <<  (Integer) ceil(val) << std::endl;
	  return (Integer) ceil(val);
	  
	}
      else
	{
	  return (Integer) floor(val);
	  
	}
      // if(ceil(val)-(val)< myPrecision)
      // 	{
      // 	  //std::cout << (Integer) ceil(val);
      // 	  return (Integer) ceil(val);
	  
      // 	} 
      // else
      // 	return (Integer) floor(val);
    }
  
}




// template <typename TInteger, typename TNumber>
// inline
// void DGtal::DSLSubsegment<TInteger,TNumber>::update(Vector u, Point A, Vector l, Vector *v)
// {
//   Point AA = A;
//   AA +=(*v);
//   Integer alpha = intersection(AA,u,l);
  
//   u *= alpha;
//    (*v) += u;
// }

template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::update(Vector u, Point A, Vector l, Integer r, Vector *v)
{
  Point AA = A;
  AA +=(*v);
  Integer alpha = intersection(AA,u,l,r);
  
  u *= alpha;
   (*v) += u;
}



template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::update(Vector u, Point A, Number s, Vector *v)
{
  Point AA = A;
  AA +=(*v);
  Integer alpha = intersection(AA,u,s);
  //std::cout << "update " << alpha << std::endl;
u *= alpha;
  (*v) += u;
}



// template <typename TInteger, typename TNumber>
// inline
// void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApprox(Vector l, Integer n, Point *inf, Point *sup)
// {
  
//   //std::cout << "In Convex hull approx" << std::endl;
  
//   if(n >= l[0])
//     {
//       *inf = l;
//       *sup = l;
//     }
//   else
//     if(l[1] == 0)
//       {
//   	*inf = l;
//   	*sup = Point(n,1);
//       }
//     else
//       {
	
// 	//std::cout << "main part convexHullApprox" << std::endl;
// 	Point A = Point(0,1);
// 	Point B = Point(1,0);
// 	//Point B = Point(0,0);
	
// 	Vector u = Vector(1,-1);
// 	Vector v = Vector(1,0);
// 	//Vector u = Vector(0,-1);
// 	//Vector v = Vector(1,0);
	
// 	Vector normal = Vector(-l[1],l[0]);
	
// 	//std::cout << "normal vector " << normal << std::endl;
// 	//std::cout << "n = " << n << std::endl;
// 	Integer alpha;
	
// 	bool ok = true;
// 	bool found = false;
	
// 	while(ok)
// 	  {
// 	    if(v[0]*normal[0]+v[1]*normal[1] ==0) // should never happen
// 	      {
// 		ok = false;
// 		found = true;
// 	      }
// 	    else
// 	      if(v[0]*normal[0]+v[1]*normal[1] < 0)
// 		{
// 		  //	  std::cout << "dot product neg " <<  v << std::endl;
// 		  //std::cout << "A " << A << " B " << B  << std::endl;
// 		  alpha = min(intersection(A,v,l), intersectionVertical(A,v,n));
// 		  //std::cout << "alpha = " << alpha << std::endl;
// 		  if(alpha >= 1)
// 		    {
// 		      Vector vv  = v;
// 		      vv *= alpha;
// 		      A += vv;
// 		      u = B - A;
// 		      update(u,A,l,&v);
// 		      //std::cout << "A " << A << " B " << B  << std::endl;
// 		    }
// 		  else
// 		    ok = false;
// 		}
// 	      else
// 		if(v[0]*normal[0]+v[1]*normal[1] > 0)
// 		  {
// 		    //std::cout << "A " << A <<  " B " << B << std::endl;
// 		    alpha = min(intersection(B,v,l),intersectionVertical(B,v,n));
// 		    if(alpha >= 1)
// 		      {
// 			Vector vv = v;
// 			vv *= alpha;
// 			B += vv;
// 			u = B - A;
// 			update(u,A,l,&v);
// 		      }
// 		    else
// 		      ok = false;
// 		  }
// 	    //else
// 	    //  ok = false;
	    
// 	  }
	
// 	if(found)
// 	  {
// 	    *sup = v;
// 	    *inf = v;
// 	  }
// 	else
// 	  {
// 	    *sup = A;
// 	    //if(B != Point(0,0))
// 	    *inf = B;
// 	    //else
// 	    //*inf = Point(1,0);
// 	    assert(A[0] != B[0] || A[1] != B[1]);
// 	    ////std::cout << "end convex hull approx" << A << " " << B << std::endl;
// 	    //      }
// 	  }
//       }
// }



template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullHarPeled(Vector l, Integer n, Point *inf, Point *sup)
{
   if(n >= l[0])
     {
       *inf = l;
       *sup = l;
     }
   
   if(l[1] == 0)
     {
       *inf = l;
       *sup = Point(n,1);
     }
   else
     {
       
       Point A = Point(0,1);
       Point B = Point(1,0);
       
       int i=0;
       bool ok = true;
       Integer alpha1, alpha2, alpha;
       
       while(ok)
	 {
	   if(i%2==0)
	     {
	       alpha1 = intersection(A,B,l,0);
	       alpha2 = intersectionVertical(A,B,n);
	       alpha = min(alpha1,alpha2); 
	       A = A + alpha*B;
	       if(A[0]*l[1]-A[1]*l[0]==0 || alpha == alpha2)
		 ok = false;
	     }
	   if(i%2==1)
	     {
	       alpha1 = intersection(B,A,l,0);
	       alpha2 = intersectionVertical(B,A,n);
	       alpha = min(alpha1,alpha2);
	       B = B + alpha*A;
	       if(B[0]*l[1]-B[1]*l[0]==0 || alpha == alpha2)
		 ok = false;
	     }
	   i++;
	 }
       
       
   
       *inf = B;
       *sup = A;
     }
}





template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApprox(Vector l, Integer r, Integer n, Point *inf, Point *sup)
{
  
  //std::cout << "In Convex hull approx" << std::endl;
  
  //std::cout << l << " " << n << std::endl;

  if(n >= l[0])
    {
      *inf = l;
      *sup = l;
    }
  else
    if(l[1] == 0)
      {
  	*inf = l;
  	*sup = Point(n,1);
      }
    else
      {
	
	//std::cout << "main part convexHullApprox" << std::endl;
	Point A = Point(0,1);
	Point B = Point(1,0);
	//Point B = Point(0,0);
	
	Vector u = Vector(1,-1);
	Vector v = Vector(1,0);
	//Vector u = Vector(0,-1);
	//Vector v = Vector(1,0);
	
	Vector normal = Vector(-l[1],l[0]);
	
	//std::cout << "normal vector " << normal << std::endl;
	//std::cout << "n = " << n << std::endl;
	Integer alpha;
	
	bool ok = true;
	bool found = false;
	bool first = true;
	
	while(ok)
	  {
	    if(v[0]*normal[0]+v[1]*normal[1] ==0) // should never happen
	      {
		ok = false;
		found = true;
	      }
	    else
	      if(v[0]*normal[0]+v[1]*normal[1] < 0)
		{
		  //	  std::cout << "dot product neg " <<  v << std::endl;
		  //std::cout << "A " << A << " B " << B  << std::endl;
		  alpha = min(intersection(A,v,l,r), intersectionVertical(A,v,n));
		  //std::cout << "alpha = " << alpha << std::endl;
		  if(alpha >= 1 || first)
		    {
		      if(first && alpha ==0)
			std::cout << "A " << A << "l = " << l << " alpha = " << alpha << std::endl;
		      Vector vv  = v;
		      vv *= alpha;
		      A += vv;
		      u = B - A;
		      update(u,A,l,r,&v);
		      
		    }
		  else
		    ok = false;
		  first = false;
		}
	      else
		if(v[0]*normal[0]+v[1]*normal[1] > 0)
		  {
		    //std::cout << "A " << A <<  " B " << B << std::endl;
		    alpha = min(intersection(B,v,l,r),intersectionVertical(B,v,n));
		    if(alpha >= 1)
		      {
			Vector vv = v;
			vv *= alpha;
			B += vv;
			u = B - A;
			update(u,A,l,r,&v);
		      }
		    else
		      ok = false;
		  }
	    //else
	    //  ok = false;
	    
	  }
	
	if(found)
	  {
	    *sup = v;
	    *inf = v;
	  }
	else
	  {
	    *sup = A;
	    //if(B != Point(0,0))
	    *inf = B;
	    //else
	    //*inf = Point(1,0);
	    assert(A[0] != B[0] || A[1] != B[1]);
	    ////std::cout << "end convex hull approx" << A << " " << B << std::endl;
	    //      }
	  }
      }
}

template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApproxTwoPoints(Vector l, Integer r, Integer n, Point *inf, Point *sup, Point *prevInf, Point *prevSup, bool inv)
{
  //std::cout << "convex hull approx l = " << l << " r =" << r <<  std::endl;
  
  // if(r==0)
  //   {
  //     *inf = Point(0,0);
  //     *sup = Point(0,1);
  //     *prevInf = *inf;
  //     *prevSup = *sup;
  //   }
  // else
  // if(n >= l[0])
  //   {
  //     *inf = l;
  //     *sup = l;
  //   }
  // else
    
  //   if(l[1] == 0)
  //     {
  //     *inf = l;
  //     *sup = Point(n,1);
  //     }
  //   else

  // std::cout << l << " " << r << std::endl;
      
      Point A,B,Aold,Bold;
      Vector u,v;
      if(inv && r==0)
	{
	  A = Point(0,0);
	  B = Point(1,0);
	  u = Vector(1,0);
	  v = Vector(0,1);
	  Aold = Point(0,0);
	  Bold = B;
	}
      else
	{
	  A = Point(0,1);
	  B = Point(0,0);
	  u = Vector(0,-1);
	  v = Vector(1,0);
	  Aold = A;
	  Bold = B;
	}
      
      Vector vv;
      Vector normal = Vector(-l[1],l[0]);
      
      Integer alpha;
      
      bool ok = true;
      bool first = true;
      while(ok)
	{
	  
	  // std::cout << "A = (" << A[0] << "," << A[1] << ") B=(" << B[0] << "," << B[1] << ")" << std::endl;
	  // std::cout << "u = (" << u[0] << "," << u[1] << ") v=(" << v[0] << "," << v[1] << ")" << std::endl;
	  if(v[0]*normal[0]+v[1]*normal[1]< 0)
	    {
	      alpha = min(intersection(A,v,l,r), intersectionVertical(A,v,n));
	      //std::cout << "alpha1 = " << alpha  << std::endl;
	      if(alpha >= 1 || first)
		{
		  //Aold = A; // Aold = A + (alpha-1)*vv ?
		  vv  = v;
		  Aold = A + (alpha-1)*vv;
		  vv *= alpha;
		  A += vv;
		  //test if A is on the slope
		  if(A[0]*l[1]-A[1]*l[0]+r ==0)
		    {
		      ok = false;
		      // v = A;
		    }
		  else
		    {
		      u = B - A;
		      update(u,A,l,r,&v);
		    }
		      
		  
		}
	      else
		ok = false;
	      first = false;
	    }
	  else
	    if(v[0]*normal[0]+v[1]*normal[1]> 0)
	      {
		alpha = min(intersection(B,v,l,r),intersectionVertical(B,v,n));
		//std::cout << " alpha2 = " << alpha  << std::endl;
		if(alpha >= 1)
		  {
		    //Bold = B;
		    vv = v;
		    Bold = B + (alpha-1)*vv;
		    vv *= alpha;
		    B += vv;
		    // test if B is on the slope
		    if(B[0]*l[1]-B[1]*l[0] +r==0 )
		      {
		    	ok = false;
			//	    	v = B;
			
		      }
		    else
		      {
			
			u = B - A;
			update(u,A,l,r,&v);
		      }
		  }
		else
		  ok = false;
	      }
	    else
	      ok = false;	  
	}
      
      if(!inv)
	{
	  if(A[0]*l[1]-A[1]*l[0]+r ==0)
	    {
	      *sup = A;
	      *inf = A;
	      *prevSup = Aold;
	      *prevInf = B;
	    }
	  else
	    if(B[0]*l[1]-B[1]*l[0]+r ==0)
	      {
		*inf = B;
		*prevInf = Bold;
		if(B[0]>A[0])
		  {
		    *sup = B;
		    *prevSup = A;
		  }
		else
		  {
		    *sup = A;
		    //*prevSup = B;
		    *prevSup = Aold;
		  }
	      }
	    else
	      {
		*sup = A;
		*inf = B;
		*prevInf = Bold;
		*prevSup = Aold;
	      }
	}
      else
	{
	  if(B[0]*l[1]-B[1]*l[0]+r ==0)
	    {
	      *sup = B;
	      *inf = B;
	      *prevSup = A;
	      *prevInf = Bold;
	    }
	  else
	    if(A[0]*l[1]-A[1]*l[0]+r ==0)
	      {
		*sup = A;
		*prevSup = Aold;
		if(A[0]>B[0])
		  {
		    *inf = A;
		    *prevInf = B;
		  }
		else
		  {
		    *inf = B;
		    //*prevSup = B;
		    *prevInf = Bold;
		  }
	      }
	    else
	      {
		*sup = A;
		*inf = B;
		*prevInf = Bold;
		*prevSup = Aold;
	      }


	}



      // {
    
  //   Point A,B,Aold,Bold;
  //   Vector u,v;
  //   if(inv && r==0)
  //     {
  // 	A = Point(0,0);
  // 	B = Point(1,0);
  // 	u = Vector(1,0);
  // 	v = Vector(0,1);
  // 	Aold = Point(0,0);
  // 	Bold = B;
  // 	}
  //   else
  //     {
  // 	A = Point(0,1);
  // 	B = Point(0,0);
  // 	u = Vector(0,-1);
  // 	v = Vector(1,0);
  // 	Aold = A;
  // 	Bold = B;
  //     }
    

  //     Vector vv;
  //     Vector normal = Vector(-l[1],l[0]);
      
  //     Integer alpha;
      
  //     bool ok = true;
  //     bool  first = true;

  //     while(ok)
  // 	{
	  
  // 	  //std::cout << "A = (" << A[0] << "," << A[1] << ") B=(" << B[0] << "," << B[1] << ")" << std::endl;
  // 	  //std::cout << "u = (" << u[0] << "," << u[1] << ") v=(" << v[0] << "," << v[1] << ")" << std::endl;
  // 	  if(v[0]*normal[0]+v[1]*normal[1] == 0)
  // 	    {
  // 	      ok = false;
  // 	    }
  // 	  else
  // 	    if(v[0]*normal[0]+v[1]*normal[1]< 0)
  // 	      {
  // 		alpha = min(intersection(A,v,l,r), intersectionVertical(A,v,n));
		
  // 		if(alpha >= 1 || first)
  // 		  {
  // 		    Aold = A;
  // 		    vv  = v;
  // 		    vv *= alpha;
  // 		    A += vv;
  // 		    // test if A is on the slope
  // 		    if(A[0]*l[1]-A[1]*l[0]+r ==0)
  // 		      {
  // 			ok = false;
  // 			//	v = A;
  // 		      }
  // 		    else
  // 		      {
  // 			u = B - A;
  // 			update(u,A,l,r,&v);
  // 		      }
  // 		  }
  // 		else
  // 		  ok = false;
  // 		first = false;
  // 	      }
  // 	    else
  // 	      if(v[0]*normal[0]+v[1]*normal[1]> 0)
  // 		{
  // 		  alpha = min(intersection(B,v,l,r),intersectionVertical(B,v,n));
		  
  // 		  if(alpha >= 1)
  // 		    {
  // 		      Bold = B;
  // 		      vv = v;
  // 		      vv *= alpha;
  // 		      B += vv;
  // 		      // test if B is on the slope
  // 		      if(B[0]*l[1]-B[1]*l[0] +r==0 )
  // 			{
  // 			  ok = false;
  // 			  //v = B;
			  
  // 			}
  // 		      else
  // 			{
			  
  // 			  u = B - A;
  // 			  update(u,A,l,r,&v);
  // 			}
  // 		    }
  // 		  else
  // 		    ok = false;
  // 		}
  // 	      else
  // 		ok = false;
	  
  // 	}
      
  //     if(!inv)
  // 	{
  // 	  if(A[0]*l[1]-A[1]*l[0]+r ==0)
  // 	    {
  // 	      *sup = A;
  // 	      *inf = A;
  // 	      *prevSup = Aold;
  // 	      *prevInf = B;
  // 	    }
  // 	  else
  // 	    if(B[0]*l[1]-B[1]*l[0]+r ==0)
  // 	      {
  // 		*inf = B;
  // 		*prevInf = Bold;
  // 		if(B[0]>A[0])
  // 		  {
  // 		    *sup = B;
  // 		    *prevSup = A;
  // 		  }
  // 		else
  // 		  {
  // 		    *sup = A;
  // 		    //*prevSup = B;
  // 		    *prevSup = Aold;
  // 		  }
  // 	      }
  // 	    else
  // 	      {
  // 		*sup = A;
  // 		*inf = B;
  // 		*prevInf = Bold;
  // 		*prevSup = Aold;
  // 	      }
  // 	}
  //     else
  // 	{
  // 	  if(B[0]*l[1]-B[1]*l[0]+r ==0)
  // 	    {
  // 	      *sup = B;
  // 	      *inf = B;
  // 	      *prevSup = A;
  // 	      *prevInf = Bold;
  // 	    }
  // 	  else
  // 	    if(A[0]*l[1]-A[1]*l[0]+r ==0)
  // 	      {
  // 		*sup = A;
  // 		*prevSup = Aold;
  // 		if(A[0]>B[0])
  // 		  {
  // 		    *inf = A;
  // 		    *prevInf = B;
  // 		  }
  // 		else
  // 		  {
  // 		    *inf = B;
  // 		    //*prevSup = B;
  // 		    *prevInf = Bold;
  // 		  }
  // 	      }
  // 	    else
  // 	      {
  // 		*sup = A;
  // 		*inf = B;
  // 		*prevInf = Bold;
  // 		*prevSup = Aold;
  // 	      }


  // 	}
      
      
      
  //     }
      
}




  
template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApprox(Number s, Integer n, Point *inf, Point *sup)
{
  // slope to be approximated = (1,s)

  //std::cout << "In Convex hull approx" << std::endl;
  
  //std::cout << "main part convexHullApprox" << std::endl;
  Point A = Point(0,1);
  Point B = Point(1,0);
  //Point B = Point(0,0);
  
  Vector u = Vector(1,-1);
  Vector v = Vector(1,0);
  //Vector u = Vector(0,-1);
  //Vector v = Vector(1,0);
  
  VectorF normal = VectorF(-s,1);
  
  //std::cout << "normal vector " << normal << std::endl;
  ////std::cout << "n = " << n << std::endl;
  Integer alpha;

  bool ok = true;
  bool found = false;
  
  DGtal::IntegerComputer<Integer> ic;
      

  while(ok)
    {
      if(fabs(v[0]*normal[0]+v[1]*normal[1]) <= myPrecision)
	//if(v[0]*normal[0]+v[1]*normal[1] ==0)
	{
	  ok = false;
	  found = true;
	}
      else
	if(v[0]*normal[0]+v[1]*normal[1] < 0)
	  {
	    //	  //std::cout << "dot product neg " <<  v << std::endl;
	    //std::cout << "A " << A << " B " << B  << std::endl;
	    alpha = min(intersection(A,v,s), intersectionVertical(A,v,n));
	    //std::cout << "alpha = " << alpha << std::endl;
	    if(alpha >= 1)
	      {
		Vector vv  = v;
		vv *= alpha;
		A += vv;
		// test if A is on the slope
		//std::cout << fabs(A[0]*normal[0]+A[1]*normal[1]) << std::endl;
		if(fabs(A[0]*normal[0]+A[1]*normal[1]) <= myPrecision)
		  {
		    ok = false;
		    v = A;
		    found = true;
		  }
		else
		  {
		    u = B - A;
		    update(u,A,s,&v);
		    //std::cout << "A " << A << " B " << B  << " " << v << std::endl;
		  }
	      }
	    else
	      ok = false;
	  }
      else
	if(v[0]*normal[0]+v[1]*normal[1] > 0)
	  {
	    //std::cout << "A " << A <<  " B " << B << std::endl;
	    alpha = min(intersection(B,v,s),intersectionVertical(B,v,n));
	    if(alpha >= 1)
	      {
		Vector vv = v;
		vv *= alpha;
		B += vv;
		// test if B is on the slope
		if(fabs(B[0]*normal[0]+B[1]*normal[1]) <= myPrecision)
		  {
		    ok = false;
		    v = B;
		    found = true;
		  }
		else
		  {
		    u = B - A;
		    update(u,A,s,&v);
		  }
	      }
	    else
	      ok = false;
	  }
      //else
      //  ok = false;
      
    }
  
  if(found)
    {
      Integer g = ic.gcd(v[0],v[1]);
      v[0] = v[0]/g;
      v[1] = v[1]/g;
      *sup = v;
      *inf = v;
    }
  else
    {
      *sup = A;
      //if(B != Point(0,0))
      *inf = B;
      //else
      //*inf = Point(1,0);
      assert(A[0] != B[0] || A[1] != B[1]);
      ////std::cout << "end convex hull approx" << A << " " << B << std::endl;
      //      }
    }
}




// Compute the term following f=p/q in the Farey Series of order n. We
// have -q'p+p'q = 1, q' max such that q'<=n
// Complexity of extendedEuclid
template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Point DGtal::DSLSubsegment<TInteger,TNumber>::nextTermInFareySeriesEuclid(Integer fp, Integer fq, Integer n)
{
  Integer u,v;
  // u*p+v*q = 1

  DGtal::IntegerComputer<Integer> ic;
  Point p;
  p = ic.extendedEuclid(fp,fq,1);
  
  u = p[0];
  v = p[1];
  
  Integer pp = v;
  Integer qq = -u;
  
  pp = pp + floor((n+u)/fq)*fp;
  qq = qq + floor((n+u)/fq)*fq;
  
  return Point(qq,pp);
}


// Compute the term following fp/fq in the Farey sequence of order n
// knowing a fraction gp/gq that is the successor of fp/fq in the Farey
// sequence of order m.
// If m < n, then the result is in between fp/fq and gp/gq
// Otherwise, the result is greater than gp/gq

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Point DGtal::DSLSubsegment<TInteger,TNumber>::nextTermInFareySeries(Integer fp, Integer fq, Integer gp, Integer gq, Integer m, Integer n)
{
  Integer p;
  Integer q;
  Integer k;
  
  if(m<n)
    {
      k = floor((long double) (n-gq)/fq);
      p = gp + k*fp;
      q = gq + k*fq;
    }
  else
    {
      k = ceil((long double) (gq-n)/fq);
      p = gp - k*fp;
      q = gq - k*fq;
      if(gq<fq)
	std::cout << "ici" << fq << " " << gq << " " << p << " " << q << std::endl;
      
    }
  
  return Point(q,p);
}




template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::rayOfHighestSlope(Integer p, Integer q, Integer r, Integer smallestSlope, Integer n)
 {
   //return RayC(p,q,r,smallestSlope+floor((FloatType) (n-smallestSlope)/q)*q);
   return RayC(p,q,r,n-(n-smallestSlope)%q);
 }

// Template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Integer a, Integer b, Integer mu)
// {
//   return (Integer) ceil((FloatType) (r*b-mu*q)/(-p*b+a*q)); 
// }

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Number DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Number a, Number b, Number mu)
{
  BOOST_CONCEPT_ASSERT((CInteger<TNumber>));
  return (Integer) ceil((FloatType) (r*b-mu*q)/(-p*b+a*q)); 
}

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Number DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Number alpha, Number beta)
{
  
  Number val = (r-beta*q)/(-p+alpha*q);
  
  // if the value is very close to a slightly smaller integer, we keep the close integer
  //std::cout << "slope = " << val << std::endl;
  if(val-floor(val) <= myPrecision)
    return((Integer) floor(val));
  else
    return((Integer) ceil(val));

  //return (Integer) ceil(((Number) (r-beta*q)/(Number) (-p+alpha*q)));
}



// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Integer a, Integer b, Integer mu)
// {
//   Integer v = -a*r.x + r.y*b - mu;
  
  
//   if(v == 0)
//     return ONTO;
//   else
//     if(v > 0)
//       return BELOW;
//     else
//       if(v < 0)
// 	return ABOVE;
  
// }

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Number a, Number b, Number mu)
{
  BOOST_CONCEPT_ASSERT((CInteger<TNumber>));
  Integer v = -a*r.x + r.y*b - mu;
  
  //trace.info() << "v = " << v << std::endl;

  if(v == 0)
    return ONTO;
  else
    if(v > 0)
      return BELOW;
    else
      if(v < 0)
	return ABOVE;
  
}


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Number alpha, Number beta)
{
  Number v = -alpha*r.x + r.y - beta;
  
  //trace.info() << "v = " << v << std::endl;


  //if(v == 0)
  if(fabs(v) <= myPrecision )
    {
      //std::cout << "here" << std::endl;
      return ONTO;
    }
  else
    if(v > 0)
      return BELOW;
    else
      if(v < 0)
	return ABOVE;
}



template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::smartRayOfSmallestSlope(Integer fp, Integer fq, Integer gp, Integer gq, Integer r) 
 {
   // Version 1: using floor operator
   Integer rr;
   if(r == fq)
     rr = gq;
   else
     //rr = (Integer) floor((FloatType) (r*gq)/fq);
     rr = (r*gq)/fq;
   
   // Version 2: performing a dichotomy. Integer only version but slightly less performant
   // We look for r'/q' such that r'/q' <= r/q <= (r'+1)/q', which is equilavent to -q <= r'q-rq' <= 0 
   // Integer rr = 0;
   // if(r == fq)
   //   rr = gq;
   // else
   //   {
       
   //     Integer lup = gq;
   //     Integer ldown = 0;
       
   //     bool flag = false;
   //     Integer value;
   //     while((lup>=2 || ldown >=2) && !flag)
   // 	 {
   // 	   value = rr*fq - r*gq;
   // 	   if(-fq <= value && value <= 0) 
   // 	     {
   // 	       flag = true;
   // 	       if(value == -fq)
   // 		 rr++;
   // 	     }
   // 	   else
   // 	     if(value < -fq)
   // 	       // check upper part
   // 	       {
   // 		 rr = rr + ((lup%2 == 0)?lup/2:(lup-1)/2);
   // 		 ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
   // 		 lup = ((lup%2==0)?lup/2:(lup+1)/2);
   // 	       }
   // 	     else // value > 0 -> check lower part
   // 	       {
   // 		 rr = rr - ((ldown%2==0)?ldown/2:(ldown+1)/2);
   // 		 lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
   // 		 ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
   // 	       }
   // 	 }
   //  }
       
      
   //std::cout << "smart ray of smallest slope" << std::endl;
   
   // Compute the slope of the line through (f=p/Q,r/q) and
   // (g=p'/q',rr/q')
   Integer x = (r*gq - rr*fq)/*/(gp*fq-fp*gq)*/; 
   
   //Integer y = (r+fp*x)/fq;
   Integer y = r*gp-rr*fp; // after simplification of the above formula
   
   return RayC(x,y);

 }
 


// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Integer a, Integer b, Integer mu, Integer n, bool *flagRayFound)
// {
  
//   RayC myRay;
//   Position myPosition;
//   Integer r = 0;
//   Integer lup = fq;
//   Integer ldown = 0;
  
//   *flagRayFound = false;
  
// #ifdef DEBUG
//   //trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
// #endif  
  
  
//   //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
//   while((lup>=2 || ldown >=2) && !*flagRayFound)
//     {
//       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
//       myPosition = positionWrtRay(myRay,a,b,mu);
       
// #ifdef DEBUG 
//       //trace.info() << r << " " << myRay.x << " " << myRay.y << std::endl;
// #endif

//       if(myPosition == ONTO)
// 	 *flagRayFound = true;
//       else
// 	if(myPosition == ABOVE)
// 	  {
// 	    //r = r + (int) floor((double) lup/2);
// 	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
// 	    //ldown = (int) floor((double) lup/2);
// 	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
// 	    //lup = (int) ceil((double) lup/2);
// 	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
// 	  }
// 	else
// 	  {
// 	    //r = r - (int) ceil((double) ldown/2);
// 	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
// 	    //lup = (int) ceil((double) ldown/2);
// 	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
// 	    //ldown = (int) floor((double) ldown/2);
// 	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
// 	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
//     }
  
//   // If the point is not on a ray of smallest slope
//    if(!*flagRayFound)
//      {
//        myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
//        myPosition = positionWrtRay(myRay,a,b,mu);
       
//        if(myPosition != ONTO)
// 	 {
// 	   if(myPosition == ABOVE)
// 	     r++;
	   
// 	   if(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)
// 	     {
// 	       r--;
// 	       *flagRayFound = true;
// 	     }
// 	 }
//        else
// 	 *flagRayFound = true;
       
//      }
   
// #ifdef DEBUG
//    //trace.info() << r << std::endl;
// #endif
   
//    return r;
//  }


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Number a, Number b, Number mu, Integer n, bool *flagRayFound)
{
  BOOST_CONCEPT_ASSERT((CInteger<Number>));
    
  RayC myRay;
  Position myPosition;
  Integer r = 0;
  Integer lup = fq;
  Integer ldown = 0;
  
  *flagRayFound = false;
  
// #ifdef DEBUG
//   //trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
// #endif  
  
  
  //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
  while((lup>=2 || ldown >=2) && !*flagRayFound)
    {
      myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
      myPosition = positionWrtRay(myRay,a,b,mu);
  
       
#ifdef DEBUG 
      trace.info() << "height " << r << " Ray " << myRay.x << " " << myRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif


      if(myPosition == ONTO)
	 *flagRayFound = true;
      else
	if(myPosition == ABOVE)
	  {
	    //r = r + (int) floor((double) lup/2);
	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
	    //ldown = (int) floor((double) lup/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    //lup = (int) ceil((double) lup/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    //r = r - (int) ceil((double) ldown/2);
	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //lup = (int) ceil((double) ldown/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //ldown = (int) floor((double) ldown/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
    }
  
  // If the point is not on a ray of smallest slope
   if(!*flagRayFound)
     {
       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
       myPosition = positionWrtRay(myRay,a,b,mu);
       
       //trace.info() << "myPosition = " << myPosition << std::endl;

       if(myPosition != ONTO)
	 {
	   if(myPosition == ABOVE)
	     r++;
	   
	   //std::cout << "diff = " << fabs(slope(fp, fq,r,a,b,mu)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   RayC SteepestRay = rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n);
	   //std::cout << "compare stepest ray" << std::endl;
	   Position pos = positionWrtRay(SteepestRay,a,b,mu);	   
	   
	   if(pos==BELOW)
	     {
	       //assert(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x);
	       //std::cout << "pos = below\n";
	       r--;
	       *flagRayFound = true;
	       
	     }
	   
	   // if(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)
	   //   {
	   //     assert(pos==BELOW);
	   //     //std::cout << "diff = " << fabs(slope(fp, fq,r,a,b,mu)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   //     r--;
	   //     *flagRayFound = true;
	   //   }
	 }
       else
	 *flagRayFound = true;
       
     }
   
#ifdef DEBUG
   trace.info() << r << std::endl;
#endif
   
   return r;
 }


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Number alpha, Number beta, Integer n, bool *flagRayFound)
{
  RayC myRay;
  Position myPosition;
  Integer r = 0;
  Integer lup = fq;
  Integer ldown = 0;
  
  *flagRayFound = false;
  
#ifdef DEBUG
  trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  
  
  //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
  while((lup>=2 || ldown >=2) && !*flagRayFound)
    {
      myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
      myPosition = positionWrtRay(myRay,alpha,beta);
      
#ifdef DEBUG 
      trace.info() << "height " << r << " Ray " << myRay.x << " " << myRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif
      
      if(myPosition == ONTO)
	*flagRayFound = true;
      else
	if(myPosition == ABOVE)
	  {
	    //r = r + (int) floor((double) lup/2);
	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
	    //ldown = (int) floor((double) lup/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    //lup = (int) ceil((double) lup/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    //r = r - (int) ceil((double) ldown/2);
	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //lup = (int) ceil((double) ldown/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //ldown = (int) floor((double) ldown/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
    }
  
  // If the point is not on a ray of smallest slope
   if(!*flagRayFound)
     {
       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
       myPosition = positionWrtRay(myRay,alpha,beta);
       
       //trace.info() << "myPosition = " << myPosition << std::endl;

       if(myPosition != ONTO)
	 {
	   if(myPosition == ABOVE)
	     r++;
	   
	   RayC SteepestRay = rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n);
	   //std::cout << "compare stepest ray" << std::endl;
	   Position pos = positionWrtRay(SteepestRay,alpha,beta);
	   
	   if(pos == BELOW)
	     {
	       //std::cout << "pos = below\n";
	       r--;
	       *flagRayFound = true;
	     }
	       
	   // if(slope(fp, fq,r,alpha,beta)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x && fabs(slope(fp, fq,r,alpha,beta)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)>myPrecision)
	   //   {
	   //     //std::cout << "diff = " << fabs(slope(fp, fq,r,alpha,beta)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   //     r--;
	   //     *flagRayFound = true;
	   //   }
	 }
       else
	 *flagRayFound = true;
       
     }
   
#ifdef DEBUG
   trace.info() << r << std::endl;
#endif
   
   return r;
}



template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number a, Number b, Number mu,  Integer n)
{
  BOOST_CONCEPT_ASSERT((CInteger<Number>));
  //std::cout << "fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
  //std::cout << "a = " << a << " b= " << b << " mu = " << mu << std::endl;
  Number alpha = slope(fp, fq,r,a,b,mu);
  //std::cout << "slope = " << alpha << std::endl;
  
  Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; // le
   // récupérer
   // car on
   // l'a déjà calculé
   
   
  if(alpha%(fq) == smallestSlope)
    {
      return RayC(fp,fq,r,alpha);
    }
  else
    if(alpha%(fq) < smallestSlope)
      {
	return RayC(fp,fq,r,alpha + smallestSlope - alpha%(fq));
      }
    else
      // alphaInt%(f.q()) > smallestSlope
      {
	return RayC(fp,fq,r,alpha - (alpha%(fq) - smallestSlope) + fq); 
      }      
 }


// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number alpha, Number beta,  Integer n)
// {
  
//   //std::cout << "fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
//   //std::cout << std::setprecision(15) << "alpha = " << alpha << " beta= " << beta << std::endl;
   
// Number alphaF = slope(fp, fq,r,alpha,beta);
//   //std::cout << "slope = " << alphaF << std::endl;
//   Integer s = floor(alphaF); // round to the nearest lower integer
  
//   Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; 
  
//   if(s%(fq) == smallestSlope)
//     {
//       return RayC(fp,fq,r,s);
//     }
//   else
//     if(s%(fq) < smallestSlope)
//       {
// 	return RayC(fp,fq,r,s + smallestSlope - s%(fq));
//       }
//     else
//       // alphaInt%(f.q()) > smallestSlope
//       {
// 	return RayC(fp,fq,r,s - (s%(fq) - smallestSlope) + fq); 
//       }      
  
// }

// With a dichotomy
template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number alpha, Number beta,  Integer n)
{
  
  //std::cout << "dichotomy localize ray fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
  
  Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; 
  
  Integer kmax = floor((n-smallestSlope)/fq) +1;
  
  Integer k = 0;
  Integer lup = 0;
  Integer ldown = kmax;

  Position myPosition;
  
  RayC aRay;
  bool found;

  while((lup>=2 || ldown >=2) && !found)
    {
      aRay = RayC(fp,fq,r,smallestSlope+k*fq); 
      myPosition = positionWrtRay(aRay,alpha,beta);
      
#ifdef DEBUG 
      trace.info() << "k " << k << " Ray " << aRay.x << " " << aRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif
      
      if(myPosition == ONTO)
	found = true;
      else
	if(myPosition == ABOVE)
	  {
	    k = k - ((lup%2 == 0)?lup/2:(lup-1)/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    k = k + ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
    }
  
  if(!found)
    {
      aRay = RayC(fp,fq,r,smallestSlope+k*fq); 
      myPosition = positionWrtRay(aRay,alpha,beta);
      
      if(myPosition == ABOVE || myPosition == ONTO)
	return aRay;
      else
	return RayC(fp,fq,r,smallestSlope+(k+1)*fq);
    }
  else
    return aRay;
  
}




template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::raySup(Integer fp, Integer fq, RayC r)
 {
   RayC rr;
   // r is the highest ray
   if(r.x - fq < 0)
     return r;
   else
     {
       rr.x = r.x - fq;
       //Integer h = -fp*r.x +r.y*fq;
       //rr.y = (h + fp*rr.x)/(fq);
       rr.y = r.y - fp;
     }

   return rr;
 }


template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::shortFindSolution(Integer fp, Integer fq, Integer gp, Integer gq, RayC r, Integer n, Integer *resAlphaP, Integer *resAlphaQ, Integer *resBetaP, bool found)  // resBetaQ = resAlphaQ  
{
  Point inf, sup , tmpsup, tmpinf;
  IntegerComputer<Integer> ic;

  //Compute the lower edge of the facet
  if(fq <= ic.max(r.x,n-r.x))
    {
      inf[0] = fq;
      inf[1] = fp;
    }
  else
    //convexHullHarPeled(Vector(fq,fp),ic.max(r.x,n-r.x),&inf,&tmpsup);
    convexHullApprox(Vector(fq,fp),0,ic.max(r.x,n-r.x),&inf,&tmpsup);

  if(gq <= ic.max(r.x,n-r.x))
    {
      sup[0] = gq;
      sup[1] = gp;
    }
  else
    //convexHullHarPeled(Vector(gq,gp),ic.max(r.x,n-r.x),&tmpinf,&sup);
    convexHullApprox(Vector(gq,gp),0,ic.max(r.x,n-r.x),&tmpinf,&sup);
  
  
  if(r.x-inf[0] < 0) // R is the ray of smallest slope in inf
    {
      *resAlphaP = inf[1];
      *resAlphaQ = inf[0];
      *resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
    }
  else
    if(r.x+sup[0] > n) // R is the ray of highest slope in sup
      {
	*resAlphaP = sup[1];
	*resAlphaQ = sup[0];
	*resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
      }
    else  //the facet is upper triangular, 
      {
	*resAlphaP = inf[1]+sup[1];
	*resAlphaQ = inf[0]+sup[0];
	*resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
	
	// IntegerComputer<Integer> ic;
	// Integer g = ic.gcd(inf[1] + sup[1],inf[0]+sup[0]);
	// if(g!=1) std::cout << "diff ";
	// *resAlphaP = (inf[1]+sup[1])/g;
	// *resAlphaQ = (inf[0]+sup[0])/g;
	// *resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
      }
  
}




template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::findSolutionWithoutFractions(Integer fp, Integer fq, Integer gp, Integer gq, RayC r, Integer n, Integer *resAlphaP, Integer *resAlphaQ, Integer *resBetaP, bool found/*, int *ndiff, long double *timeTot*/)  // resBetaQ = resAlphaQ  
{
  
  
  Point inf, sup;
     IntegerComputer<Integer> ic;

     if(found == false)
       // r is not the highest ray on A -> A is multiple
       {
	 
	 if(gq <= ic.max(r.x,n-r.x))
	   { // B is a multiple point, r is the lowest ray on B
	     // (otherwise, there would be an intersection in [AB]
	     // between the lowest ray on B and the ray above r on A. 
	     // Thus B is the solution
	     //std::cout << "B is the solution " << std::endl;
	     *resAlphaP = gp;
	     *resAlphaQ = gq;
	     *resBetaP = -gp*r.x + r.y*gq;
	   }
	 else
	   { // compute the ray juste above r
	     //std::cout << "Neither A (nor B) is the solution, A is the
	     //highest left vertex. Find the next Farey term on the ray sup." << std::endl;
	     RayC rr = raySup(fp,fq,r);
	     // compute the fraction following f in the Farey Series
	     // given by the slope of rr 
	     
	     if(ic.max(rr.x,n-rr.x)>ic.max(r.x,n-r.x))
	       {
	    
		 //std::cout << "here " << r.x << " " <<  r.y <<  std::endl;
		 //Point next = nextTermInFareySequence(fp,fq,max(rr.x,n-rr.x));
		 //Point next = nextTermInFareySeriesEuclid(fp,fq,ic.max(rr.x,n-rr.x));
		 Point next = nextTermInFareySeries(fp,fq,gp,gq,n,ic.max(rr.x,n-rr.x));

		 *resAlphaP = next[1];
		 *resAlphaQ = next[0];
		 //*resBetaP = (Integer)
		 //*-(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
		 *resBetaP = (Integer) -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
	       }
	     else
	       {
		 
		 //Point next = nextTermInFareySequence(fp,fq,max(r.x,n-r.x));
		 
		 //Point next = nextTermInFareySeriesEuclid(fp,fq,ic.max(r.x,n-r.x));
		 Point next = nextTermInFareySeries(fp,fq,gp,gq,n,ic.max(r.x,n-r.x));
		
		      // convexHullHarPeled(Vector(fq,fp),ic.max(r.x,n-r.x),&inf,&sup);
		      // if(next != sup)
		      // 	std::cout << fp << " " << fq << " " << ic.max(r.x,n-r.x) << " " << next << " " << sup << std::endl;
		  
		 
		  
		 *resAlphaP = next[1];
		 *resAlphaQ = next[0];
		 *resBetaP = (Integer) -(*resAlphaP)*r.x+(*resAlphaQ)*r.y ;
	       }
			  
	   }
       }
     else
       {
	 //std::cout << "the ray is the upper ray" << std::endl;
	 if(fq <= ic.max(r.x,n-r.x))
	   { // A is a multiple point
	     // A is the solution
	     //std::cout << "A is a multiple point, A is the solution" << std::endl;
	     *resAlphaP = fp;
	     *resAlphaQ = fq;
	     *resBetaP = -fp*r.x +fq*r.y;
	   }
	 else
	   if(gq <= ic.max(r.x,n-r.x) && (r.x + gq) >n)
	     { // B is a multiple point and r is the lowest ray
	       // B is the solution
	       //std::cout << "B is a multiple point and r is the lowest ray: B is the solution" << std::endl; 
	       *resAlphaP = gp;
	       *resAlphaQ = gq;
	       *resBetaP = -gp*r.x +gq*r.y;
	     }
	   else
	     {
	       // A is not a multiple point. Check if the vertex above A
	       // is a multiple point
	       Integer h = -fp*r.x + r.y*fq +1;
	       RayC rr = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
	          if(fq<=ic.max(rr.x,n-rr.x))
		 {  //the vertex above A is a
		   // multiple point -> A is the solution 
		   //std::cout << "A is not multiple, but the vertex above A is: A is the solution" << std::endl;
		   *resAlphaP = fp;
		   *resAlphaQ = fq;
		   *resBetaP = -fp*r.x +fq*r.y;
		 }
		  else
		    {
		      
		   //std::cout << "Neither A nor B is the solution " << std::endl;
		   //convexHullApprox(Vector(fq,fp),0,max(r.x,n-r.x),&inf,&sup);
		      convexHullHarPeled(Vector(fq,fp),ic.max(r.x,n-r.x),&inf,&sup);
		      
		      //Point ssup = nextTermInFareySeries(fp,fq,gp,gq,n,ic.max(r.x,n-r.x));
		      //if(ssup !=sup)
		      //std::cout << "diff" << fp << " " << fq << " " << gp << " " << gq << " " << sup << " " << ssup << std::endl; 
		   // Let C be the point on r with abscissa equal to inf. 
		   RayC rr = raySup(inf[1],inf[0],r); // ray above r passing through C
		   if(rr.x == r.x) // r is the highest ray passing through C
		     { // C is the solution
		       *resAlphaP = inf[1];
		       *resAlphaQ = inf[0];
		       *resBetaP = -inf[1]*r.x + inf[0]*r.y;
		     }
		   else
		     { 
		       //std::cout << "r is not the highest ray" << std::endl;
		       if(ic.max(rr.x,n-rr.x)>ic.max(r.x,n-r.x))
			 {
			   
			   // the solution is given by the fraction following inf
			   // in the Farey Series of order
			   // max(x-inf.q(),n-(x.inf.q())), on the ray rr
			   
			   // we compute the mediant on inf and sup: if
			   // the denominator is lower or equal to the
			   // order given by the ray rr, then the
			   // mediant is the solution. Otherwise, sup is
			   // the solution.  
			   
			   
			   // Point next = nextTermInFareySeries(inf[1],inf[0],sup[1],sup[0],ic.max(r.x,n-r.x),ic.max(rr.x,n-rr.x));
			   
			   // if(next[0] <= ic.max(rr.x,n-rr.x))
			   //   {
			   //     *resAlphaP = next[1];
			   //     *resAlphaQ = next[0];
			   //   }
			   // else
			   //   {
			   //     *resAlphaP = sup[1];
			   //     *resAlphaQ = sup[0];
			   //   }
			   // *resBetaP = -(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
			   
			   Point next = inf+sup;
			   if(next[0] <= ic.max(rr.x,n-rr.x))
			     {
			       *resAlphaP = next[1];
			       *resAlphaQ = next[0];
			     }
			   else
			     {
			       *resAlphaP = sup[1];
			       *resAlphaQ = sup[0];
			     }
			   *resBetaP = -(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
			   
			   
			   // Integer g = ic.gcd(inf[1] + sup[1],inf[0]+sup[0]);
			   
			   // if((inf[0]+sup[0])/g <= ic.max(rr.x,n-rr.x))
		      // 	     {
		      // 	       *resAlphaP = (inf[1]+sup[1])/g;
		      // 	       *resAlphaQ = (inf[0]+sup[0])/g;
		      // 	     }
		      // 	   else
		      // 	     {
		      // 	       *resAlphaP = sup[1];
		      // 	       *resAlphaQ = sup[0];
		      // 	     }
		      // 		   *resBetaP = -(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
			 }
		       else
			 {
			   *resAlphaP = sup[1];
			   *resAlphaQ = sup[0];
			   *resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
			 }
		     }
		   
		   		  
		   
		 }
	       
	     }
	 
       }
     }


template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::DSLSubsegment(Number a, Number b, Number mu, Point A, Point B/*, int *ndiff, long double *timeTot*/)
{
  Integer n = B[0] - A[0];
  clock_t timeBegin, timeEnd;
  //trace.info() << "DSLSubsegment" << std::endl;
 
  if(n >= 2*b)
    {
      aa = a;
      bb = b;
      Nu = mu;
      //std::cout << "easy\t";
      //std::cout << "DSS parameters are DSL parameters." << std::endl;
      ////std::cout << " " << a << " " << b << " " << mu;
    }
  else
    {
      // A becomes the origin // mu must be between 0 and b
      mu += a*A[0] - A[1]*b;
      Point inf, sup;
      
      Point inf2, sup2;
      
      Integer fp,fq,gp,gq;
      //std::cout << " " << a << " " << b << " " << mu << std::endl; 
      ////std::cout << "mu = " << mu << std::endl;

      if(b>n)
	{
	  //convexHullApprox(Vector(b,a),0,n,&inf,&sup);
	  //(*ndiff)++;
	  //timeBegin = clock();
	  
	  convexHullHarPeled(Vector(b,a),n,&inf,&sup);
	  //timeEnd =clock();
	  //(*timeTot) += ((double)timeEnd-(double)timeBegin)/(((double)CLOCKS_PER_SEC)/1000);
	  fp = inf[1];
	  fq = inf[0];
	  gp = sup[1];
	  gq = sup[0];  
	  // assert(inf==inf2 && sup==sup2);
	  } 
      else
      	{
	  Point supL, infL;
	  
	  convexHullHarPeled(Vector(b,a),b-1,&infL,&supL);
	 
	  Point supR = Point(b,a)+Point(b,a)-infL;
	  Integer rL = supL[0]*a - supL[1]*b;
	  Integer rR = supR[0]*a - supR[1]*b;
	  Point next;
	  if(rL<rR || supR[0] > n)
	    next = supL;
	  else
	    next = supR;
	  
	  //Point next = nextTermInFareySeriesEuclid(a,b,n);
      	  // std::cout << n << " " << a << " " << b << " " << "next " << next << std::endl << std::endl; 
	  fp = a;
      	  fq = b;
      	  gp = next[1];
      	  gq = next[0];
	  
	}	
      
      
#ifdef DEBUG
      trace.info() << "fractions = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  


      bool found;
      
      // Find the height in the ladder
      // Returns the height h such that: 
      // - param is in between the rays passing through the point (inf =
      // p/q, h/q)
      // ==> found is set to false
      // - or param is above the ray of smallest slope passing through
      // (inf = p/q, h/q) but below all the rays passing through (p/q,
      // h+1/q)  ==> found is set to true
      
      // Integer fp = inf[1];
      // Integer fq = inf[0];
      // Integer gp = sup[1];
      // Integer gq = sup[0];
      
      // if(fp == gp && fq == gq)
      // 	{
      // 	  Point next = nextTermInFareySeriesEuclid(fp,fq,n);
      // 	  gp = next[1];
      // 	  gq = next[0];
      // 	}	


      Integer h = smartFirstDichotomy(fp,fq,gp,gq,a,b,mu,n,&found);
      
      RayC r;
            
      //trace.info() << "h = " << h << " found = " << found << std::endl;

      if(found)
	{
	  r = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
	  
	}
      else
	{
	  r = localizeRay(fp,fq,gp,gq,h,a,b,mu,n);      
	  
	}
      //trace.info() << "Ray =" << r.x << " " << r.y << std::endl;
      
      Integer resAlphaP=0, resAlphaQ=0, resBetaP=0;
      //findSolutionWithoutFractions(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found/*, ndiff, timeTot*/);
      shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      
      
      aa = resAlphaP;
      bb = resAlphaQ;
      Nu = resBetaP - aa*A[0] + bb*A[1];
      
  ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      ////std::cout << "Result before translation: (" << resAlpha.p() << "/" << resAlpha.q() << "," << resBetaP << ")" << std::endl;
      
      ////std::cout << "After translation " << resAlphaP << " " << resAlphaQ << " " << (Integer) floor(-resAlphaP*A[0] + resBetaP*resAlphaQ/resAlphaQ + A[1]*resAlphaQ);
      
      
       }
  
  
   }



template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::DSLSubsegment(Number alpha, Number beta,  Point A, Point B, Number precision)
{
  Integer n = B[0] - A[0];
  
  myPrecision = precision;
  
  // if(n >= 2*b)
  //   {
  //     aa = a;
  //     bb = b;
  //     Nu = mu;
  //     ////std::cout << "DSS parameters are DSL parameters." << std::endl;
  //     ////std::cout << " " << a << " " << b << " " << mu;
  //   }
  // else
  //   {
  // A becomes the origin 
  
  beta +=alpha*A[0] - A[1];
  
  Point inf, sup;
  Integer fp,fq,gp,gq;
  
    
#ifdef DEBUG
  trace.info() << "\n \nDSLSubsegment with floats, n=" << n << " precision = " << myPrecision << std::endl;
  trace.info() << std::setprecision(15) << "alpha = " << alpha << " beta = " << beta << std::endl;
#endif  
  
  
  //convexHullApprox(Vector(1,alpha),n,&inf,&sup);
  convexHullApprox(alpha,n,&inf,&sup);
  fp = inf[1];
  fq = inf[0];
  gp = sup[1];
  gq = sup[0];    
  
  
#ifdef DEBUG
  trace.info() << "f and g = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  

  if(fp == gp && fq == gq)
    {
      //std::cout << " compute next" << std::endl;
      Point next = nextTermInFareySeriesEuclid(fp,fq,n);
      gp = next[1];
      gq = next[0];
      
    }

    
#ifdef DEBUG
  //trace.info() << "f and g = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  

  bool found;
  
  //std::cout << "after convex hull approx" << std::endl;

  // Find the height in the ladder
  // Returns the height h such that: 
  // - param is in between the rays passing through the point (inf =
  // p/q, h/q)
  // ==> found is set to false
  // - or param is above the ray of smallest slope passing through
  // (inf = p/q, h/q) but below all the rays passing through (p/q,
  // h+1/q)  ==> found is set to true
  
  // Integer fp = inf[1];
  // Integer fq = inf[0];
  // Integer gp = sup[1];
  // Integer gq = sup[0];
  
  // if(fp == gp && fq == gq)
  // 	{
  // 	  Point next = nextTermInFareySeriesEuclid(fp,fq,n);
  // 	  gp = next[1];
  // 	  gq = next[0];
  // 	}	
  
  
  Integer h = smartFirstDichotomy(fp,fq,gp,gq,alpha,beta,n,&found);
  
  //std::cout << "after smart dicho, h = " << h << " found = " << found << std::endl;

  RayC r;
  
  if(found)
    r = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
  else
    r = localizeRay(fp,fq,gp,gq,h,alpha,beta,n);      
  
  //trace.info() << "Ray =" << r.x << " " << r.y << std::endl;


  Integer resAlphaP=0, resAlphaQ=0, resBetaP=0;
  findSolutionWithoutFractions(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
  //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
  
  
  aa = resAlphaP;
  bb = resAlphaQ;
  Nu = resBetaP - aa*A[0] + bb*A[1];
  
  ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      ////std::cout << "Result before translation: (" << resAlpha.p() << "/" << resAlpha.q() << "," << resBetaP << ")" << std::endl;
      
      ////std::cout << "After translation " << resAlphaP << " " << resAlphaQ << " " << (Integer) floor(-resAlphaP*A[0] + resBetaP*resAlphaQ/resAlphaQ + A[1]*resAlphaQ);
      
      
      //}
  
  
}


template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::filterUpperCH(Vector l, Number mu, Point sup[4])
{
  DGtal::IntegerComputer<Integer> ic;


    Integer g;
  
    Point P = sup[1];
    //check if sup[0] == sup[1] ?
    if(P[0]*l[1] - P[1]*l[0] + mu==0 )
      {
	Vector v1 = sup[2] - sup[0];
	Vector v2 = sup[1] - sup[0];
	
	if(v1[0]*v2[1]-v1[1]*v2[0] ==1) // if the vectors are unimodular
	  {
	    if(v1[0]==0 || v1[1]==0)
	      g = ic.max((Integer) 1,ic.max(v1[0],v1[1]));
	    else
	      g = ic.gcd(v1[0],v1[1]);
	    std::cout << v1 << " " << g << std::endl;
	    sup[1] = sup[0]+(g-1)*(v1/g);
	  }
      else
	{
	  Vector v3 = sup[2] - sup[1];
	  if(v3[0]==0 || v3[1]==0)
	    g = ic.max((Integer) 1,ic.max(v3[0],v3[1]));
	  else
	    g = ic.gcd(v3[0],v3[1]);
	  sup[2] = sup[1] + (v3/g);
	  
	  
	  if(v2[0]==0 || v2[1]==0)
	    g = ic.max((Integer) 1,ic.max(v2[0],v2[1]));
	  else
	    g = ic.gcd(v2[0],v2[1]);
	  std::cout << "v2 = " <<  v2 << " " << g << std::endl;
	  sup[1] = sup[0]+(g-1)*(v2/g);
	}
      }
    
    P = sup[2];
    if(P[0]*l[1] - P[1]*l[0] + mu==0 )
      {
      Vector v1 = sup[3] - sup[1];
      Vector v2 = sup[2] - sup[1];

      
      if(v1[0]*v2[1]-v1[1]*v2[0] ==1) // if the vectors are unimodular
	{
	  if(v1[0]==0 || v1[1]==0)
	    g = ic.max((Integer) 1,ic.max(v1[0],v1[1]));
	  else
	    g = ic.gcd(v1[0],v1[1]);
	  std::cout << v1 << " " << g << std::endl;
	  sup[2] = sup[1]+(g-1)*(v1/g);
	}
      else
	{
	  Vector v3 = sup[3] - sup[2];
	  if(v3[0]==0 || v3[1]==0)
	    g = ic.max((Integer) 1,ic.max(v3[0],v3[1]));
	  else 
	    g = ic.gcd(v3[0],v3[1]);
	  sup[3] = sup[2] + (v3/g);
	  
	  if(v2[0]==0 || v2[1]==0)
	    g = ic.max((Integer) 1,ic.max(v2[0],v2[1]));
	  else
	    g = ic.gcd(v2[0],v2[1]);
	  sup[2] = sup[1]+(g-1)*(v2/g);
	}


    }




  // Point P = sup[1];
  // //check if sup[0] == sup[1] ?
  // if(P[0]*l[1] - P[1]*l[0] + mu==0 )
  //   {
  //     Vector v = sup[2] - sup[0];
  //     Integer g;
  //     if(v[0]==0 || v[1]==0)
  // 	g = 1;
  //     else
  // 	g = ic.gcd(v[0],v[1]);
  //     std::cout << v << " " << g << std::endl;
  //     sup[1] = sup[0]+(g-1)*(v/g);
  //   }
  
  // P = sup[2];
  // if(P[0]*l[1] - P[1]*l[0] + mu==0 )
  //   {
  //     Vector v = sup[3] - sup[1];
  //     Integer g;
  //     if(v[0]==0 || v[1]==0)
  // 	g = 1;
  //     else
  // 	g = ic.gcd(v[0],v[1]);
  //     std::cout << v << " " << g << std::endl;
  //     sup[2] = sup[1]+(v/g);
  //   }
  
}


template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::lowerConvexHull(Vector l, Integer mu, Point A, Point B, Point *prevInfL, Point *infL, Point *infR, Point *prevInfR)
{
  // std::cout << "lower convex hull" << std::endl;
  // std::cout << l << " " << mu << " " << A << " " << B << std::endl;
  
  Integer rA = l[1]*A[0]-l[0]*A[1] + mu;
  Integer rB = l[1]*B[0]-l[0]*B[1] + mu;
  
  Point prevSupL,supL,supR,prevSupR;

  // from left to right
  convexHullApproxTwoPoints(l,rA,B[0]-A[0],infL,&supL,prevInfL,&prevSupL,0); // computation of the left part of the convex hulls
  
  
  *infL += A;
  supL += A;
  
  *prevInfL +=A;
  prevSupL +=A;

  // std::cout << "prevInfL = " << *prevInfL << "   prevSupL = " << prevSupL << std::endl; 
  // std::cout << "infL = " << *infL << "   supL = " << supL << std::endl; 
  
  // from right to left
  if(rB !=0)
    {
      convexHullApproxTwoPoints(l,l[0]-rB,B[0]-A[0],infR,&supR,prevInfR,&prevSupR,1);
      
      Point B1 = B + Point(0,1);
      
      *infR = B1 - *infR;
      supR = B1 - supR;
      
      Point tmp;
      tmp = *infR;
      *infR = supR;
      supR = tmp;
      
      
      *prevInfR = B1 - *prevInfR;
      prevSupR = B1 - prevSupR;
      
      tmp = *prevInfR;
      *prevInfR = prevSupR;
      prevSupR = tmp;
    }
  else
    {
      convexHullApproxTwoPoints(l,0,B[0]-A[0],infR,&supR,prevInfR,&prevSupR,1);
      
      *infR = B - *infR;
      supR = B - supR;
      
      Point tmp;
      tmp = *infR;
      *infR = supR;
      supR = tmp;
      
      
      *prevInfR = B - *prevInfR;
      prevSupR = B - prevSupR;
      
      tmp = *prevInfR;
      *prevInfR = prevSupR;
      prevSupR = tmp;

    }
  
  
  // std::cout << "prevInfR = " << *prevInfR << "   prevSupR = " << prevSupR << std::endl;
  // std::cout << "infR = " << *infR << "   supR = " << supR << std::endl; 
  


}




// Contructor calling the localConvexHull approx instead of the walk in the Farey Fan -> should be a new class.
template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::DSLSubsegment(Number a, Number b, Number mu, Point A, Point B, bool flag)
{
  Integer n = B[0] - A[0];
  
  
  if(n >= 2*b)
    {
      aa = a;
      bb = b;
      Nu = mu;
      //std::cout << "DSS parameters are DSL parameters." << std::endl;
      ////std::cout << " " << a << " " << b << " " << mu;
    }
  else
    {


  Integer rA = a*A[0]-b*A[1] + mu;
  Integer rB = a*B[0]-b*B[1] + mu;
  
  Vector l(b,a);
  
  Point infL,supL,infR,supR,prevInfL,prevSupL,prevInfR,prevSupR;
  
  lowerConvexHull(l,mu,A,B,&prevInfL,&infL,&infR,&prevInfR);
  
  // std::cout << "Final \n";
  // std::cout << "prevInfL = " << prevInfL << "   infL = " << infL << std::endl;
  // std::cout << "infR = " << infR << "   prevInfR = " << prevInfR << std::endl; 
  

  
  lowerConvexHull(l,l[0]-rB-1,Point(0,0),B-A,&prevSupR, &supR, &supL, &prevSupL);
  
   prevSupR = B+Point(0,1)-prevSupR;
   supR = B+Point(0,1)-supR;
   prevSupL = B+Point(0,1)-prevSupL;
   supL = B+Point(0,1)-supL;
   

  // std::cout << "Final \n";
  
  // std::cout << "prevSupL = " << prevSupL << "   supL = " << supL << std::endl;
  // std::cout << "supR = " << supR << "   prevSupR = " << prevSupR << std::endl; 
  
    
  DGtal::IntegerComputer<Integer> ic;
  
  aa=0, bb=0, Nu=0;
  
  // we are left with four possible lines given by the couples (prevInfL, infL=infR) (infL = infR,prevInfR)
  // (prevSupL, supL = supR) (supL = supR, prevSupR)
  // the solution is given by the slope with bigger b
  
  
	Point inf[4];
	
	inf[0] = prevInfL;
	inf[1] = infL; 
	inf[2] = infR;
	inf[3] = prevInfR;

	

	Point sup[4];
	
	sup[0] = prevSupL;
	sup[1] = supL; 
	sup[2] = supR;
	sup[3] = prevSupR;

	
	
	Integer atmp, btmp;
	for(int i=0;i<3;i++)
	  {
	    btmp = inf[i+1][0] - inf[i][0];
	    atmp = inf[i+1][1] - inf[i][1];
	    // Integer g;
	    // if(atmp==0 || btmp==0)
	    //   g = ic.max((Integer) 1,ic.max(atmp,btmp));
	    // else
	      
	    // 	g = ic.gcd(btmp,atmp);
	  
	    // if(g !=1)
	    // 	  std::cout << "diff" << std::endl;
	    
	    // btmp = btmp/g;
	    // atmp = atmp/g;
	    if(btmp > bb)
	      {
		bb =btmp;
		aa =atmp;
	      }
	  }
	
	
	for(int i=0;i<3;i++)
	  {
	    btmp = sup[i+1][0] - sup[i][0];
	    atmp = sup[i+1][1] - sup[i][1];
	    // Integer g;
	    // if(atmp==0 || btmp==0)
	    //   g = ic.max((Integer) 1,ic.max(atmp,btmp));
	    // else
	    //   g = ic.gcd(btmp,atmp);
	  
	    //   if(g !=1)
	    // 	  std::cout << "diff" << std::endl;
	  
	    // btmp = btmp/g;
	    // atmp = atmp/g;
	    if(btmp > bb)
	      {
		bb =btmp;
		aa =atmp;
	      }
	  }
	
	
	
	Nu = -aa*infL[0] + bb*infL[1];
	
	
	
	//	std::cout << "a = " << aa << " b = " << bb << " mu = " << Nu << std::endl << std::endl;
	
	
    }
  
}



