/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DSLSubsegment.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2012/07/17
 *
 * Implementation of inline methods defined in DSLSubsegment.h
 *
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

#define DEBUG

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC()
{}

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC(const Integer x0, const Integer y0)
{
  x = x0;
  y = y0;
} 

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::RayC(const Integer p , const Integer q, const Integer r, const Integer slope)
{
  x = slope;
  y = (r+p*x)/q;
}

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::RayC::~RayC()
{
}


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::min (Integer a, Integer b)
{
  if(a<b)
    return a;
  else 
    return b;
}

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersectionVertical(Point P, Vector v, Integer n)
{
  if(v[0] == 0)
    return n;
  else
    {
      return (Integer) floor((FloatType) (n-P[0])/v[0]);
    }
} 





template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersection(Point P, Vector v, Vector aL)
{
  if(v[0]==0)
    {
      return (Integer) floor((FloatType) (aL[1]*P[0] - aL[0]*P[1])/(v[1]*aL[1]));
    }
  else
    //if(v[0] != 0)
    {
      Number num = -P[1]*aL[0]*v[0] - P[0]*(v[1]*aL[0] - aL[1]*v[0]) + aL[0]*v[1]*P[0];
      Number denom = v[0]*(v[1]*aL[0] - aL[1]*v[0]);
      return (Integer) floor((FloatType) num/denom);
    }
}


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::intersection(Point P, Vector v, Number s)
{
  // vector to be approximated = (1,s)
  
  if(v[0]==0)
    {
      Number val = (s*P[0] - P[1])/(v[1]*s);
      if(ceil(val)-val <= myPrecision) // val is very close and slightly under an integer -> consider that it is equal to the integer
	return (Integer) ceil(val);
      else
	return (Integer) floor(val);
    }
  else
    {
      //std::cout << "intersection P, V and slope " << P << " " << v << " " << s << std::endl;
      Number num = -P[1]*v[0] - P[0]*(v[1] - s*v[0]) + v[1]*P[0];
      Number denom = v[0]*(v[1] - s*v[0]);
      Number val = num/denom;
      
      Number val2 = (P[1]-s*P[0])/(s*v[0]-v[1]); // using parametric definition of lines and solving for t -> not more precise than the other computation...
      
      Number val3;
      PointF Q;
      Q[0] = P[0] + ceil(val)*v[0];
      Q[1] = P[1] + ceil(val)*v[1];
      
      val3 = (Number) Q[0]*s - (Number) Q[1];
      
      //std::cout << Q << std::endl;
      //std::cout << std::setprecision(15) << "val 3 = " << Q[0]*s - Q[1] << std::endl;
      
      //std::cout << std::setprecision(15) << "intersection " << num << " " << denom << " " << val << " " << val2 << std::endl;
      
      if(fabs(val3) <= myPrecision)
	{
	  //std::cout << " ceil " <<  (Integer) ceil(val) << std::endl;
	  return (Integer) ceil(val);
	  
	}
      else
	{
	  return (Integer) floor(val);
	  
	}
      // if(ceil(val)-(val)< myPrecision)
      // 	{
      // 	  //std::cout << (Integer) ceil(val);
      // 	  return (Integer) ceil(val);
	  
      // 	} 
      // else
      // 	return (Integer) floor(val);
    }
  
}




template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::update(Vector u, Point A, Vector l, Vector *v)
{
  Point AA = A;
  AA +=(*v);
  Integer alpha = intersection(AA,u,l);
  
  u *= alpha;
   (*v) += u;
}

template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::update(Vector u, Point A, Number s, Vector *v)
{
  Point AA = A;
  AA +=(*v);
  Integer alpha = intersection(AA,u,s);
  //std::cout << "update " << alpha << std::endl;
u *= alpha;
  (*v) += u;
}



template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApprox(Vector l, Integer n, Point *inf, Point *sup)
{
  
  //std::cout << "In Convex hull approx" << std::endl;
  
  if(n >= l[0])
    {
      *inf = l;
      *sup = l;
    }
  else
    if(l[1] == 0)
      {
  	*inf = l;
  	*sup = Point(n,1);
      }
    else
      {
	
	//std::cout << "main part convexHullApprox" << std::endl;
	Point A = Point(0,1);
	Point B = Point(1,0);
	//Point B = Point(0,0);
	
	Vector u = Vector(1,-1);
	Vector v = Vector(1,0);
	//Vector u = Vector(0,-1);
	//Vector v = Vector(1,0);
	
	Vector normal = Vector(-l[1],l[0]);
	
	//std::cout << "normal vector " << normal << std::endl;
	//std::cout << "n = " << n << std::endl;
	Integer alpha;
	
	bool ok = true;
	bool found = false;
	
	while(ok)
	  {
	    if(v[0]*normal[0]+v[1]*normal[1] ==0) // should never happen
	      {
		ok = false;
		found = true;
	      }
	    else
	      if(v[0]*normal[0]+v[1]*normal[1] < 0)
		{
		  //	  std::cout << "dot product neg " <<  v << std::endl;
		  //std::cout << "A " << A << " B " << B  << std::endl;
		  alpha = min(intersection(A,v,l), intersectionVertical(A,v,n));
		  //std::cout << "alpha = " << alpha << std::endl;
		  if(alpha >= 1)
		    {
		      Vector vv  = v;
		      vv *= alpha;
		      A += vv;
		      u = B - A;
		      update(u,A,l,&v);
		      //std::cout << "A " << A << " B " << B  << std::endl;
		    }
		  else
		    ok = false;
		}
	      else
		if(v[0]*normal[0]+v[1]*normal[1] > 0)
		  {
		    //std::cout << "A " << A <<  " B " << B << std::endl;
		    alpha = min(intersection(B,v,l),intersectionVertical(B,v,n));
		    if(alpha >= 1)
		      {
			Vector vv = v;
			vv *= alpha;
			B += vv;
			u = B - A;
			update(u,A,l,&v);
		      }
		    else
		      ok = false;
		  }
	    //else
	    //  ok = false;
	    
	  }
	
	if(found)
	  {
	    *sup = v;
	    *inf = v;
	  }
	else
	  {
	    *sup = A;
	    //if(B != Point(0,0))
	    *inf = B;
	    //else
	    //*inf = Point(1,0);
	    assert(A[0] != B[0] || A[1] != B[1]);
	    ////std::cout << "end convex hull approx" << A << " " << B << std::endl;
	    //      }
	  }
      }
}
  
template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::convexHullApprox(Number s, Integer n, Point *inf, Point *sup)
{
  // slope to be approximated = (1,s)

  //std::cout << "In Convex hull approx" << std::endl;
  
  //std::cout << "main part convexHullApprox" << std::endl;
  Point A = Point(0,1);
  Point B = Point(1,0);
  //Point B = Point(0,0);
  
  Vector u = Vector(1,-1);
  Vector v = Vector(1,0);
  //Vector u = Vector(0,-1);
  //Vector v = Vector(1,0);
  
  VectorF normal = VectorF(-s,1);
  
  //std::cout << "normal vector " << normal << std::endl;
  ////std::cout << "n = " << n << std::endl;
  Integer alpha;

  bool ok = true;
  bool found = false;
  
  DGtal::IntegerComputer<Integer> ic;
      

  while(ok)
    {
      if(fabs(v[0]*normal[0]+v[1]*normal[1]) <= myPrecision)
	//if(v[0]*normal[0]+v[1]*normal[1] ==0)
	{
	  ok = false;
	  found = true;
	}
      else
	if(v[0]*normal[0]+v[1]*normal[1] < 0)
	  {
	    //	  //std::cout << "dot product neg " <<  v << std::endl;
	    //std::cout << "A " << A << " B " << B  << std::endl;
	    alpha = min(intersection(A,v,s), intersectionVertical(A,v,n));
	    //std::cout << "alpha = " << alpha << std::endl;
	    if(alpha >= 1)
	      {
		Vector vv  = v;
		vv *= alpha;
		A += vv;
		// test if A is on the slope
		//std::cout << fabs(A[0]*normal[0]+A[1]*normal[1]) << std::endl;
		if(fabs(A[0]*normal[0]+A[1]*normal[1]) <= myPrecision)
		  {
		    ok = false;
		    v = A;
		    found = true;
		  }
		else
		  {
		    u = B - A;
		    update(u,A,s,&v);
		    //std::cout << "A " << A << " B " << B  << " " << v << std::endl;
		  }
	      }
	    else
	      ok = false;
	  }
      else
	if(v[0]*normal[0]+v[1]*normal[1] > 0)
	  {
	    //std::cout << "A " << A <<  " B " << B << std::endl;
	    alpha = min(intersection(B,v,s),intersectionVertical(B,v,n));
	    if(alpha >= 1)
	      {
		Vector vv = v;
		vv *= alpha;
		B += vv;
		// test if B is on the slope
		if(fabs(B[0]*normal[0]+B[1]*normal[1]) <= myPrecision)
		  {
		    ok = false;
		    v = B;
		    found = true;
		  }
		else
		  {
		    u = B - A;
		    update(u,A,s,&v);
		  }
	      }
	    else
	      ok = false;
	  }
      //else
      //  ok = false;
      
    }
  
  if(found)
    {
      Integer g = ic.gcd(v[0],v[1]);
      v[0] = v[0]/g;
      v[1] = v[1]/g;
      *sup = v;
      *inf = v;
    }
  else
    {
      *sup = A;
      //if(B != Point(0,0))
      *inf = B;
      //else
      //*inf = Point(1,0);
      assert(A[0] != B[0] || A[1] != B[1]);
      ////std::cout << "end convex hull approx" << A << " " << B << std::endl;
      //      }
    }
}




// Compute the term following f=p/q in the Farey Series of order n. We
// have -q'p+p'q = 1, q' max such that q'<=n
// Complexity of extendedEuclid
template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Point DGtal::DSLSubsegment<TInteger,TNumber>::nextTermInFareySeriesEuclid(Integer fp, Integer fq, Integer n)
{
  Integer u,v;
  // u*p+v*q = 1

  DGtal::IntegerComputer<Integer> ic;
  Point p;
  p = ic.extendedEuclid(fp,fq,1);
  
  u = p[0];
  v = p[1];
  
  Integer pp = v;
  Integer qq = -u;
  
  pp = pp + floor((n+u)/fq)*fp;
  qq = qq + floor((n+u)/fq)*fq;
  
  return Point(qq,pp);
}



template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::rayOfHighestSlope(Integer p, Integer q, Integer r, Integer smallestSlope, Integer n)
 {
   //return RayC(p,q,r,smallestSlope+floor((FloatType) (n-smallestSlope)/q)*q);
   return RayC(p,q,r,n-(n-smallestSlope)%q);
 }

// Template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Integer a, Integer b, Integer mu)
// {
//   return (Integer) ceil((FloatType) (r*b-mu*q)/(-p*b+a*q)); 
// }

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Number DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Number a, Number b, Number mu)
{
  BOOST_CONCEPT_ASSERT((CInteger<TNumber>));
  return (Integer) ceil((FloatType) (r*b-mu*q)/(-p*b+a*q)); 
}

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Number DGtal::DSLSubsegment<TInteger,TNumber>::slope(Integer p, Integer q, Integer r, Number alpha, Number beta)
{
  
  Number val = (r-beta*q)/(-p+alpha*q);
  
  // if the value is very close to a slightly smaller integer, we keep the close integer
  //std::cout << "slope = " << val << std::endl;
  if(val-floor(val) <= myPrecision)
    return((Integer) floor(val));
  else
    return((Integer) ceil(val));

  //return (Integer) ceil(((Number) (r-beta*q)/(Number) (-p+alpha*q)));
}



// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Integer a, Integer b, Integer mu)
// {
//   Integer v = -a*r.x + r.y*b - mu;
  
  
//   if(v == 0)
//     return ONTO;
//   else
//     if(v > 0)
//       return BELOW;
//     else
//       if(v < 0)
// 	return ABOVE;
  
// }

template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Number a, Number b, Number mu)
{
  BOOST_CONCEPT_ASSERT((CInteger<TNumber>));
  Integer v = -a*r.x + r.y*b - mu;
  
  //trace.info() << "v = " << v << std::endl;

  if(v == 0)
    return ONTO;
  else
    if(v > 0)
      return BELOW;
    else
      if(v < 0)
	return ABOVE;
  
}


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Position DGtal::DSLSubsegment<TInteger,TNumber>::positionWrtRay(RayC r, Number alpha, Number beta)
{
  Number v = -alpha*r.x + r.y - beta;
  
  //trace.info() << "v = " << v << std::endl;


  //if(v == 0)
  if(fabs(v) <= myPrecision )
    {
      //std::cout << "here" << std::endl;
      return ONTO;
    }
  else
    if(v > 0)
      return BELOW;
    else
      if(v < 0)
	return ABOVE;
}



template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::smartRayOfSmallestSlope(Integer fp, Integer fq, Integer gp, Integer gq, Integer r) 
 {
   // Version 1: using floor operator
   Integer rr;
   if(r == fq)
     rr = gq;
   else
     rr = (Integer) floor((FloatType) (r*gq)/fq);
   
   // Version 2: performing a dichotomy. Integer only version but slightly less performant
   // We look for r'/q' such that r'/q' <= r/q <= (r'+1)/q', which is equilavent to -q <= r'q-rq' <= 0 
   // Integer rr = 0;
   // if(r == fq)
   //   rr = gq;
   // else
   //   {
       
   //     Integer lup = gq;
   //     Integer ldown = 0;
       
   //     bool flag = false;
   //     Integer value;
   //     while((lup>=2 || ldown >=2) && !flag)
   // 	 {
   // 	   value = rr*fq - r*gq;
   // 	   if(-fq <= value && value <= 0) 
   // 	     {
   // 	       flag = true;
   // 	       if(value == -fq)
   // 		 rr++;
   // 	     }
   // 	   else
   // 	     if(value < -fq)
   // 	       // check upper part
   // 	       {
   // 		 rr = rr + ((lup%2 == 0)?lup/2:(lup-1)/2);
   // 		 ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
   // 		 lup = ((lup%2==0)?lup/2:(lup+1)/2);
   // 	       }
   // 	     else // value > 0 -> check lower part
   // 	       {
   // 		 rr = rr - ((ldown%2==0)?ldown/2:(ldown+1)/2);
   // 		 lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
   // 		 ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
   // 	       }
   // 	 }
   //  }
       
      
   //std::cout << "smart ray of smallest slope" << std::endl;
   
   // Compute the slope of the line through (f=p/Q,r/q) and
   // (g=p'/q',rr/q')
   Integer x = (r*gq - rr*fq)/*/(gp*fq-fp*gq)*/; 
   
   //Integer y = (r+fp*x)/fq;
   Integer y = r*gp-rr*fp; // after simplification of the above formula
   
   return RayC(x,y);

 }
 


// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Integer a, Integer b, Integer mu, Integer n, bool *flagRayFound)
// {
  
//   RayC myRay;
//   Position myPosition;
//   Integer r = 0;
//   Integer lup = fq;
//   Integer ldown = 0;
  
//   *flagRayFound = false;
  
// #ifdef DEBUG
//   //trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
// #endif  
  
  
//   //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
//   while((lup>=2 || ldown >=2) && !*flagRayFound)
//     {
//       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
//       myPosition = positionWrtRay(myRay,a,b,mu);
       
// #ifdef DEBUG 
//       //trace.info() << r << " " << myRay.x << " " << myRay.y << std::endl;
// #endif

//       if(myPosition == ONTO)
// 	 *flagRayFound = true;
//       else
// 	if(myPosition == ABOVE)
// 	  {
// 	    //r = r + (int) floor((double) lup/2);
// 	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
// 	    //ldown = (int) floor((double) lup/2);
// 	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
// 	    //lup = (int) ceil((double) lup/2);
// 	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
// 	  }
// 	else
// 	  {
// 	    //r = r - (int) ceil((double) ldown/2);
// 	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
// 	    //lup = (int) ceil((double) ldown/2);
// 	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
// 	    //ldown = (int) floor((double) ldown/2);
// 	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
// 	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
//     }
  
//   // If the point is not on a ray of smallest slope
//    if(!*flagRayFound)
//      {
//        myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
//        myPosition = positionWrtRay(myRay,a,b,mu);
       
//        if(myPosition != ONTO)
// 	 {
// 	   if(myPosition == ABOVE)
// 	     r++;
	   
// 	   if(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)
// 	     {
// 	       r--;
// 	       *flagRayFound = true;
// 	     }
// 	 }
//        else
// 	 *flagRayFound = true;
       
//      }
   
// #ifdef DEBUG
//    //trace.info() << r << std::endl;
// #endif
   
//    return r;
//  }


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Number a, Number b, Number mu, Integer n, bool *flagRayFound)
{
  BOOST_CONCEPT_ASSERT((CInteger<Number>));
    
  RayC myRay;
  Position myPosition;
  Integer r = 0;
  Integer lup = fq;
  Integer ldown = 0;
  
  *flagRayFound = false;
  
// #ifdef DEBUG
//   //trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
// #endif  
  
  
  //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
  while((lup>=2 || ldown >=2) && !*flagRayFound)
    {
      myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
      myPosition = positionWrtRay(myRay,a,b,mu);
  
       
#ifdef DEBUG 
      trace.info() << "height " << r << " Ray " << myRay.x << " " << myRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif


      if(myPosition == ONTO)
	 *flagRayFound = true;
      else
	if(myPosition == ABOVE)
	  {
	    //r = r + (int) floor((double) lup/2);
	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
	    //ldown = (int) floor((double) lup/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    //lup = (int) ceil((double) lup/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    //r = r - (int) ceil((double) ldown/2);
	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //lup = (int) ceil((double) ldown/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //ldown = (int) floor((double) ldown/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
    }
  
  // If the point is not on a ray of smallest slope
   if(!*flagRayFound)
     {
       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
       myPosition = positionWrtRay(myRay,a,b,mu);
       
       //trace.info() << "myPosition = " << myPosition << std::endl;

       if(myPosition != ONTO)
	 {
	   if(myPosition == ABOVE)
	     r++;
	   
	   //std::cout << "diff = " << fabs(slope(fp, fq,r,a,b,mu)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   RayC SteepestRay = rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n);
	   //std::cout << "compare stepest ray" << std::endl;
	   Position pos = positionWrtRay(SteepestRay,a,b,mu);	   
	   
	   if(pos==BELOW)
	     {
	       //assert(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x);
	       //std::cout << "pos = below\n";
	       r--;
	       *flagRayFound = true;
	       
	     }
	   
	   // if(slope(fp, fq,r,a,b,mu)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)
	   //   {
	   //     assert(pos==BELOW);
	   //     //std::cout << "diff = " << fabs(slope(fp, fq,r,a,b,mu)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   //     r--;
	   //     *flagRayFound = true;
	   //   }
	 }
       else
	 *flagRayFound = true;
       
     }
   
#ifdef DEBUG
   trace.info() << r << std::endl;
#endif
   
   return r;
 }


template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::Integer DGtal::DSLSubsegment<TInteger,TNumber>::smartFirstDichotomy(Integer fp, Integer fq, Integer gp, Integer gq, Number alpha, Number beta, Integer n, bool *flagRayFound)
{
  RayC myRay;
  Position myPosition;
  Integer r = 0;
  Integer lup = fq;
  Integer ldown = 0;
  
  *flagRayFound = false;
  
#ifdef DEBUG
  trace.info() << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  
  
  //while(((double) lup/2>=1 || (double) ldown/2 >=1) && !*flagRayFound)
  while((lup>=2 || ldown >=2) && !*flagRayFound)
    {
      myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
      myPosition = positionWrtRay(myRay,alpha,beta);
      
#ifdef DEBUG 
      trace.info() << "height " << r << " Ray " << myRay.x << " " << myRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif
      
      if(myPosition == ONTO)
	*flagRayFound = true;
      else
	if(myPosition == ABOVE)
	  {
	    //r = r + (int) floor((double) lup/2);
	    r = r + ((lup%2 == 0)?lup/2:(lup-1)/2);
	    //ldown = (int) floor((double) lup/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    //lup = (int) ceil((double) lup/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    //r = r - (int) ceil((double) ldown/2);
	    r = r - ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //lup = (int) ceil((double) ldown/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    //ldown = (int) floor((double) ldown/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
      
      
// #ifdef DEBUG 
//       //trace.info() << r << " " << lup << " " << ldown << std::endl;
// #endif    
    }
  
  // If the point is not on a ray of smallest slope
   if(!*flagRayFound)
     {
       myRay = smartRayOfSmallestSlope(fp,fq,gp,gq,r);
       myPosition = positionWrtRay(myRay,alpha,beta);
       
       //trace.info() << "myPosition = " << myPosition << std::endl;

       if(myPosition != ONTO)
	 {
	   if(myPosition == ABOVE)
	     r++;
	   
	   RayC SteepestRay = rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n);
	   //std::cout << "compare stepest ray" << std::endl;
	   Position pos = positionWrtRay(SteepestRay,alpha,beta);
	   
	   if(pos == BELOW)
	     {
	       //std::cout << "pos = below\n";
	       r--;
	       *flagRayFound = true;
	     }
	       
	   // if(slope(fp, fq,r,alpha,beta)>rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x && fabs(slope(fp, fq,r,alpha,beta)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x)>myPrecision)
	   //   {
	   //     //std::cout << "diff = " << fabs(slope(fp, fq,r,alpha,beta)-rayOfHighestSlope(fp, fq,r,(smartRayOfSmallestSlope(fp,fq,gp,gq,r)).x,n).x) << std::endl;
	   //     r--;
	   //     *flagRayFound = true;
	   //   }
	 }
       else
	 *flagRayFound = true;
       
     }
   
#ifdef DEBUG
   trace.info() << r << std::endl;
#endif
   
   return r;
}



template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number a, Number b, Number mu,  Integer n)
 {
   BOOST_CONCEPT_ASSERT((CInteger<Number>));
   //std::cout << "fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
   //std::cout << "a = " << a << " b= " << b << " mu = " << mu << std::endl;
   Number alpha = slope(fp, fq,r,a,b,mu);
   //std::cout << "slope = " << alpha << std::endl;
   
   Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; // le
   // récupérer
   // car on
   // l'a déjà calculé
   
   
  if(alpha%(fq) == smallestSlope)
    {
      return RayC(fp,fq,r,alpha);
    }
  else
    if(alpha%(fq) < smallestSlope)
      {
	return RayC(fp,fq,r,alpha + smallestSlope - alpha%(fq));
      }
    else
      // alphaInt%(f.q()) > smallestSlope
      {
	return RayC(fp,fq,r,alpha - (alpha%(fq) - smallestSlope) + fq); 
      }      
 }


// template <typename TInteger, typename TNumber>
// inline
// typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number alpha, Number beta,  Integer n)
// {
  
//   //std::cout << "fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
//   //std::cout << std::setprecision(15) << "alpha = " << alpha << " beta= " << beta << std::endl;
   
// Number alphaF = slope(fp, fq,r,alpha,beta);
//   //std::cout << "slope = " << alphaF << std::endl;
//   Integer s = floor(alphaF); // round to the nearest lower integer
  
//   Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; 
  
//   if(s%(fq) == smallestSlope)
//     {
//       return RayC(fp,fq,r,s);
//     }
//   else
//     if(s%(fq) < smallestSlope)
//       {
// 	return RayC(fp,fq,r,s + smallestSlope - s%(fq));
//       }
//     else
//       // alphaInt%(f.q()) > smallestSlope
//       {
// 	return RayC(fp,fq,r,s - (s%(fq) - smallestSlope) + fq); 
//       }      
  
// }

// With a dichotomy
template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::localizeRay(Integer fp, Integer fq, Integer gp, Integer gq, Integer r, Number alpha, Number beta,  Integer n)
{
  
  //std::cout << "dichotomy localize ray fp/fq = " << fp << "/" << fq << " r= " << r <<std::endl;
  
  Integer smallestSlope = smartRayOfSmallestSlope(fp,fq,gp,gq,r).x; 
  
  Integer kmax = floor((n-smallestSlope)/fq) +1;
  
  Integer k = 0;
  Integer lup = 0;
  Integer ldown = kmax;

  Position myPosition;
  
  RayC aRay;
  bool found;

  while((lup>=2 || ldown >=2) && !found)
    {
      aRay = RayC(fp,fq,r,smallestSlope+k*fq); 
      myPosition = positionWrtRay(aRay,alpha,beta);
      
#ifdef DEBUG 
      trace.info() << "k " << k << " Ray " << aRay.x << " " << aRay.y << std::endl;
      trace.info() << "myPosition " << myPosition << std::endl;
#endif
      
      if(myPosition == ONTO)
	found = true;
      else
	if(myPosition == ABOVE)
	  {
	    k = k - ((lup%2 == 0)?lup/2:(lup-1)/2);
	    ldown = ((lup%2 ==0)?lup/2:(lup-1)/2);
	    lup = ((lup%2==0)?lup/2:(lup+1)/2);
	  }
	else
	  {
	    k = k + ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    lup = ((ldown%2==0)?ldown/2:(ldown+1)/2);
	    ldown = ((ldown%2==0)?ldown/2:(ldown-1)/2);
	  }       
    }
  
  if(!found)
    {
      aRay = RayC(fp,fq,r,smallestSlope+k*fq); 
      myPosition = positionWrtRay(aRay,alpha,beta);
      
      if(myPosition == ABOVE || myPosition == ONTO)
	return aRay;
      else
	return RayC(fp,fq,r,smallestSlope+(k+1)*fq);
    }
  else
    return aRay;
  
}




template <typename TInteger, typename TNumber>
inline
typename DGtal::DSLSubsegment<TInteger,TNumber>::RayC DGtal::DSLSubsegment<TInteger,TNumber>::raySup(Integer fp, Integer fq, RayC r)
 {
   RayC rr;
   // r is the highest ray
   if(r.x - fq < 0)
     return r;
   else
     {
       rr.x = r.x - fq;
       //Integer h = -fp*r.x +r.y*fq;
       //rr.y = (h + fp*rr.x)/(fq);
       rr.y = r.y - fp;
     }

   return rr;
 }


template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::shortFindSolution(Integer fp, Integer fq, Integer gp, Integer gq, RayC r, Integer n, Integer *resAlphaP, Integer *resAlphaQ, Integer *resBetaP, bool found)  // resBetaQ = resAlphaQ  
{
  Point inf, sup , tmpsup, tmpinf;
  
  //Compute the lower edge of the facet
  if(fq <= max(r.x,n-r.x))
    {
      inf[0] = fq;
      inf[1] = fp;
    }
  else
    convexHullApprox(Vector(fq,fp),max(r.x,n-r.x),&inf,&tmpsup);

  if(gq <= max(r.x,n-r.x))
    {
      sup[0] = gq;
      sup[1] = gp;
    }
  else
    convexHullApprox(Vector(gq,gp),max(r.x,n-r.x),&tmpinf,&sup);
  
  
  if(r.x-inf[0] < 0) // R is the ray of smallest slope in inf
    {
      *resAlphaP = inf[1];
      *resAlphaQ = inf[0];
      *resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
    }
  else
    if(r.x+sup[0] > n) // R is the ray of highest slope in sup
      {
	*resAlphaP = sup[1];
	*resAlphaQ = sup[0];
	*resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
      }
    else  //the facet is upper triangular, 
      {
	IntegerComputer<Integer> ic;
	Integer g = ic.gcd(inf[1] + sup[1],inf[0]+sup[0]);
	*resAlphaP = (inf[1]+sup[1])/g;
	*resAlphaQ = (inf[0]+sup[0])/g;
	*resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
      }
  
}




template <typename TInteger, typename TNumber>
inline
void DGtal::DSLSubsegment<TInteger,TNumber>::findSolutionWithoutFractions(Integer fp, Integer fq, Integer gp, Integer gq, RayC r, Integer n, Integer *resAlphaP, Integer *resAlphaQ, Integer *resBetaP, bool found)  // resBetaQ = resAlphaQ  
    {
     Point inf, sup;
  
     if(found == false)
       // r is not the highest ray on A
       {
	 
	 if(gq <= max(r.x,n-r.x))
	   { // B is a multiple point, r is the lowest ray on B
	     // (otherwise, there would be an intersection in [AB]
	     // between the lowest ray on B and the ray above r on A. 
	     // Thus B is the solution
	     //std::cout << "B is the solution " << std::endl;
	     *resAlphaP = gp;
	     *resAlphaQ = gq;
	     *resBetaP = -gp*r.x + r.y*gq;
	   }
	 else
	   { // compute the ray juste above r
	     //std::cout << "Neither A (nor B) is the solution, A is the higher left vertex. Find the next Farey term on the ray sup." << std::endl;
	     RayC rr = raySup(fp,fq,r);
	     // compute the fraction following f in the Farey Series
	     // given by the slope of rr 
	     if(max(rr.x,n-rr.x)>max(r.x,n-r.x))
	       {
		 //std::cout << "here " << r.x << " " <<  r.y <<  std::endl;
		 //Point next = nextTermInFareySequence(fp,fq,max(rr.x,n-rr.x));
		 Point next = nextTermInFareySeriesEuclid(fp,fq,max(rr.x,n-rr.x));
		 *resAlphaP = next[1];
		 *resAlphaQ = next[0];
		 //*resBetaP = (Integer)
		 //*-(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
		 *resBetaP = (Integer) -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
	       }
	     else
	       {
		 
		 //Point next = nextTermInFareySequence(fp,fq,max(r.x,n-r.x));
		 Point next = nextTermInFareySeriesEuclid(fp,fq,max(r.x,n-r.x));
		 *resAlphaP = next[1];
		 *resAlphaQ = next[0];
		 *resBetaP = (Integer) -(*resAlphaP)*r.x+(*resAlphaQ)*r.y ;
	       }
	   }
       }
     else
       {
	 //std::cout << "the ray is the upper ray" << std::endl;
	 if(fq <= max(r.x,n-r.x))
	   { // A is a multiple point
	     // A is the solution
	     //std::cout << "A is a multiple point, A is the solution" << std::endl;
	     *resAlphaP = fp;
	     *resAlphaQ = fq;
	     *resBetaP = -fp*r.x +fq*r.y;
	   }
	 else
	   if(gq <= max(r.x,n-r.x) && (r.x + gq) >n)
	     { // B is a multiple point and r is the lowest ray
	       // B is the solution
	       //std::cout << "B is a multiple point and r is the lowest ray: B is the solution" << std::endl; 
	       *resAlphaP = gp;
	       *resAlphaQ = gq;
	       *resBetaP = -gp*r.x +gq*r.y;
	     }
	   else
	     {
	       // A is not a multiple point. Check if the vertex above A
	       // is a multiple point
	       Integer h = -fp*r.x + r.y*fq +1;
	       RayC rr = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
	       if(fq<=max(rr.x,n-rr.x))
		 {  //the vertex above A is a
		   // multiple point -> A is the solution 
		   //std::cout << "A is not multiple, but the vertex above A is: A is the solution" << std::endl;
		   *resAlphaP = fp;
		   *resAlphaQ = fq;
		   *resBetaP = -fp*r.x +fq*r.y;
		 }
	       else
		 {
		   //std::cout << "Neither A nor B is the solution " << std::endl;
		   convexHullApprox(Vector(fq,fp),max(r.x,n-r.x),&inf,&sup);
		   // Let C be the point on r with abscissa equal to inf. 
		   RayC rr = raySup(inf[1],inf[0],r); // ray above r passing through C
		   if(rr.x == r.x) // r is the highest ray passing through C
		     { // C is the solution
		       *resAlphaP = inf[1];
		       *resAlphaQ = inf[0];
		       *resBetaP = -inf[1]*r.x + inf[0]*r.y;
		     }
		   else
		     { 
		       //std::cout << "r is not the highest ray" << std::endl;
		       if(max(rr.x,n-rr.x)>max(r.x,n-r.x))
			 {
			   // the solution is given by the fraction following inf
			   // in the Farey Series of order
			   // max(x-inf.q(),n-(x.inf.q())), on the ray rr
			   
			   // we compute the mediant on inf and sup: if
			   // the denominator is lower or equal to the
			   // order given by the ray rr, then the
			   // mediant is the solution. Otherwise, sup is
			   // the solution.  
			   IntegerComputer<Integer> ic;
			   Integer g = ic.gcd(inf[1] + sup[1],inf[0]+sup[0]);
			   if((inf[0]+sup[0])/g <= max(rr.x,n-rr.x))
			     {
			       *resAlphaP = (inf[1]+sup[1])/g;
			       *resAlphaQ = (inf[0]+sup[0])/g;
			     }
			   else
			     {
			       *resAlphaP = sup[1];
			       *resAlphaQ = sup[0];
			     }
			   *resBetaP = -(*resAlphaP)*rr.x+(*resAlphaQ)*rr.y - 1;
			 }
		       else
			 {
			   *resAlphaP = sup[1];
			   *resAlphaQ = sup[0];
			   *resBetaP = -(*resAlphaP)*r.x+(*resAlphaQ)*r.y;
			 }
		     }
		   
		   
		 }
	       
	     }
	 
       }
    }

template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::DSLSubsegment(Number a, Number b, Number mu, Point A, Point B)
{
  Integer n = B[0] - A[0];
  
  //trace.info() << "DSLSubsegment" << std::endl;
 
  if(n >= 2*b)
    {
      aa = a;
      bb = b;
      Nu = mu;
      //std::cout << "DSS parameters are DSL parameters." << std::endl;
      ////std::cout << " " << a << " " << b << " " << mu;
    }
  else
    {
      // A becomes the origin // mu must be between 0 and b
      mu += a*A[0] - A[1]*b;
      Point inf, sup;
      Integer fp,fq,gp,gq;
      //std::cout << " " << a << " " << b << " " << mu << std::endl; 
      ////std::cout << "mu = " << mu << std::endl;

      if(b>n)
	{
	  convexHullApprox(Vector(b,a),n,&inf,&sup);
	  fp = inf[1];
	  fq = inf[0];
	  gp = sup[1];
	  gq = sup[0];  
	  } 
      else
      	{
      	  Point next = nextTermInFareySeriesEuclid(a,b,n);
      	  fp = a;
      	  fq = b;
      	  gp = next[1];
      	  gq = next[0];
      	}	
      
      
#ifdef DEBUG
      trace.info() << "fractions = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  


      bool found;
      
      // Find the height in the ladder
      // Returns the height h such that: 
      // - param is in between the rays passing through the point (inf =
      // p/q, h/q)
      // ==> found is set to false
      // - or param is above the ray of smallest slope passing through
      // (inf = p/q, h/q) but below all the rays passing through (p/q,
      // h+1/q)  ==> found is set to true
      
      // Integer fp = inf[1];
      // Integer fq = inf[0];
      // Integer gp = sup[1];
      // Integer gq = sup[0];
      
      // if(fp == gp && fq == gq)
      // 	{
      // 	  Point next = nextTermInFareySeriesEuclid(fp,fq,n);
      // 	  gp = next[1];
      // 	  gq = next[0];
      // 	}	


      Integer h = smartFirstDichotomy(fp,fq,gp,gq,a,b,mu,n,&found);
      
      RayC r;
            
      //trace.info() << "h = " << h << " found = " << found << std::endl;

      if(found)
	r = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
      else
	r = localizeRay(fp,fq,gp,gq,h,a,b,mu,n);      
      
      //trace.info() << "Ray =" << r.x << " " << r.y << std::endl;
      
      Integer resAlphaP=0, resAlphaQ=0, resBetaP=0;
      findSolutionWithoutFractions(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      
      
      aa = resAlphaP;
      bb = resAlphaQ;
      Nu = resBetaP - aa*A[0] + bb*A[1];
      
  ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      ////std::cout << "Result before translation: (" << resAlpha.p() << "/" << resAlpha.q() << "," << resBetaP << ")" << std::endl;
      
      ////std::cout << "After translation " << resAlphaP << " " << resAlphaQ << " " << (Integer) floor(-resAlphaP*A[0] + resBetaP*resAlphaQ/resAlphaQ + A[1]*resAlphaQ);
      
      
       }
  
  
   }



template <typename TInteger, typename TNumber>
inline
DGtal::DSLSubsegment<TInteger,TNumber>::DSLSubsegment(Number alpha, Number beta,  Point A, Point B, Number precision)
{
  Integer n = B[0] - A[0];
  
  myPrecision = precision;
  
  // if(n >= 2*b)
  //   {
  //     aa = a;
  //     bb = b;
  //     Nu = mu;
  //     ////std::cout << "DSS parameters are DSL parameters." << std::endl;
  //     ////std::cout << " " << a << " " << b << " " << mu;
  //   }
  // else
  //   {
  // A becomes the origin 
  
  beta +=alpha*A[0] - A[1];
  
  Point inf, sup;
  Integer fp,fq,gp,gq;
  
    
#ifdef DEBUG
  trace.info() << "\n \nDSLSubsegment with floats, n=" << n << " precision = " << myPrecision << std::endl;
  trace.info() << std::setprecision(15) << "alpha = " << alpha << " beta = " << beta << std::endl;
#endif  
  
  std::cout << alpha;

  
  //convexHullApprox(Vector(1,alpha),n,&inf,&sup);
  convexHullApprox(alpha,n,&inf,&sup);
  fp = inf[1];
  fq = inf[0];
  gp = sup[1];
  gq = sup[0];    
  
  
#ifdef DEBUG
  trace.info() << "f and g = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  

  if(fp == gp && fq == gq)
    {
      //std::cout << " compute next" << std::endl;
      Point next = nextTermInFareySeriesEuclid(fp,fq,n);
      gp = next[1];
      gq = next[0];
      
    }

    
#ifdef DEBUG
  //trace.info() << "f and g = " << fp << " " << fq << " " << gp << " " << gq << std::endl;
#endif  
  

  bool found;
  
  //std::cout << "after convex hull approx" << std::endl;

  // Find the height in the ladder
  // Returns the height h such that: 
  // - param is in between the rays passing through the point (inf =
  // p/q, h/q)
  // ==> found is set to false
  // - or param is above the ray of smallest slope passing through
  // (inf = p/q, h/q) but below all the rays passing through (p/q,
  // h+1/q)  ==> found is set to true
  
  // Integer fp = inf[1];
  // Integer fq = inf[0];
  // Integer gp = sup[1];
  // Integer gq = sup[0];
  
  // if(fp == gp && fq == gq)
  // 	{
  // 	  Point next = nextTermInFareySeriesEuclid(fp,fq,n);
  // 	  gp = next[1];
  // 	  gq = next[0];
  // 	}	
  
  
  Integer h = smartFirstDichotomy(fp,fq,gp,gq,alpha,beta,n,&found);
  
  //std::cout << "after smart dicho, h = " << h << " found = " << found << std::endl;

  RayC r;
  
  if(found)
    r = smartRayOfSmallestSlope(fp,fq,gp,gq,h);
  else
    r = localizeRay(fp,fq,gp,gq,h,alpha,beta,n);      
  
  //trace.info() << "Ray =" << r.x << " " << r.y << std::endl;


  Integer resAlphaP=0, resAlphaQ=0, resBetaP=0;
  findSolutionWithoutFractions(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
  //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
  
  
  aa = resAlphaP;
  bb = resAlphaQ;
  Nu = resBetaP - aa*A[0] + bb*A[1];
  
  ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      //shortFindSolution(fp,fq, gp, gq, r, n, &resAlphaP, &resAlphaQ, &resBetaP, found);
      ////std::cout << "Result before translation: (" << resAlphaP << "/" << resAlphaQ << "," << resBetaP << ")" << std::endl;
      ////std::cout << "Result before translation: (" << resAlpha.p() << "/" << resAlpha.q() << "," << resBetaP << ")" << std::endl;
      
      ////std::cout << "After translation " << resAlphaP << " " << resAlphaQ << " " << (Integer) floor(-resAlphaP*A[0] + resBetaP*resAlphaQ/resAlphaQ + A[1]*resAlphaQ);
      
      
      //}
  
  
}









