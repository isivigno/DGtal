/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Polygon.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2013/01/28
 *
 * Implementation of inline methods defined in Polygon.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


template <typename TCoordinate>
inline
DGtal::Polygon<TCoordinate>::Polygon()
{
  
}

template <typename TCoordinate>
inline
DGtal::Polygon<TCoordinate>::Polygon(const Polygon<TCoordinate> &other):myPoints(other.myPoints)
{
  
}


template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate>::Self&
DGtal::Polygon<TCoordinate>::operator=( const Polygon<TCoordinate> & other )
{
  if ( this != &other )
    {
      myPoints = other.myPoints;
    }
  return *this;
}

template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate >::PointList DGtal::Polygon<TCoordinate>::getPoints()
{
  return myPoints;
}

template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate >::Point DGtal::Polygon<TCoordinate>::getLast()
{
  return myPoints.back();
}



template <typename TCoordinate>
inline
void DGtal::Polygon<TCoordinate>::addPoint(const DGtal::Polygon<TCoordinate>::Point p)
{
  myPoints.push_back(p);
}

/*************************************************************************/
/**** Intersection of convex polygons ************************************/

/*
This code is described in "Computational Geometry in C" (Second Edition),
Chapter 7.  It is not written to be comprehensible without the
explanation in that book.

Written by Joseph O'Rourke.
Last modified: December 1997
Questions to orourke@cs.smith.edu.
--------------------------------------------------------------------
This code is Copyright 1997 by Joseph O'Rourke.  It may be freely
redistributed in its entirety provided that this copyright notice is
not removed.
--------------------------------------------------------------------
*/
/* Translated in C++ with template coordinates by I.Sivignon (01/2013) */

/*************************************************************************/



/*---------------------------------------------------------------------
---------------------------------------------------------------------*/
Template <typename TCoordinate>
inline
bool  DGtal::Polygon<TCoordinate>::convexIntersect(const Polygon & other, Polygon *Res )
/* P(=this) has n vertices, Q(=other) has m vertices. */
{
   int     a, b;           /* indices on P and Q (resp.) */
   int     a1, b1;         /* a-1, b-1 (resp.) */
   Point A, B;           /* directed edges on P and Q (resp.) */
   int     cross;          /* sign of z-component of A x B */
   int     bHA, aHB;       /* b in H(A); a in H(b). */
   Point Origin = Point(2,0); /* (0,0) */
   Point p;              /* double point of intersection */
   Point q;              /* second point of intersection */
   InFlag inflag;         /* {Pin, Qin, Unknown}: which inside */
   int     aa, ba;         /* # advances on a & b indices (after 1st inter.) (counters)*/
   bool    FirstPoint;     /* Is this the first point? (used to initialize).*/
   Point p0;             /* The first point. */
   int     code;           /* SegSegInt return code. */ 

   PointList P=myPoints;
   PointList Q=other.myPoints;


   int n = P.size();
   int m = Q.size();
     
   /* Initialize variables. */
     a = 0; b = 0; aa = 0; ba = 0;
   inflag = Unknown; FirstPoint = true;

   do {

      /* Computations of key variables. */
     a1 = (a + n - 1) % n; // compute point a-1
     b1 = (b + m - 1) % m; // compute point b-1
     
     A = SubVec( P[a], P[a1]); // compute vector A = a1a
     B = SubVec( Q[b], Q[b1]); // compute vector B = b1b
     
     cross = AreaSign( Origin, A, B );
     aHB   = AreaSign( Q.at(b1), Q.at(b), P.at(a) ); // compute position of a wrt halfplane defined by B
     bHA   = AreaSign( P.at(a1), P.at(a), Q.at(b) ); // compute position of b wrt halfplane defined by A
#ifdef DEBUG
     printf("%%cross=%d, aHB=%d, bHA=%d\n", cross, aHB, bHA );
#endif
     /* If A & B intersect, update inflag. */
     code = SegSegInt( P[a1], P[a], Q[b1], Q[b], &p, &q );
#ifdef DEBUG 
     printf("%%SegSegInt: code = %c\n", code );
#endif     
     if ( code == '1' || code == 'v' ) {
       if ( inflag == Unknown && FirstPoint ) {
	 aa = ba = 0;
	 FirstPoint = false;
	 p0.push_back(p[0]); 
	 p0.push_back(p[1]);
	 Res->addPoint(p0);

       }
       inflag = InOut( p, inflag, aHB, bHA,Res );
  
     }
     
     /*-----Advance rules-----*/
     
     /* Special case: A & B overlap (collinear and share a point) and oppositely oriented. */
     if ( ( code == 'e' ) && (Dot( A, B ) < 0) )
       PrintSharedSeg( p, q,Res ), 
	 exit(EXIT_SUCCESS);
      
     /* Special case: A & B parallel and separated. */
     if ( (cross == 0) && ( aHB < 0) && ( bHA < 0 ) )
       printf("%%P and Q are disjoint.\n"), exit(EXIT_SUCCESS);
      
      else 
	/* Special case: A & B collinear. */
	if ( (cross == 0) && ( aHB == 0) && ( bHA == 0 ) ) {
	  /* Advance but do not output point. */
	  if ( inflag == Pin )
	    b = Advance( b, &ba, m, inflag == Qin, Q[b], Res );
	  else
	    a = Advance( a, &aa, n, inflag == Pin, P[a], Res );
	}
      
      /* Generic cases. */
	else 
	  if ( cross >= 0 ) {
	    if ( bHA > 0)
	      a = Advance( a, &aa, n, inflag == Pin, P[a], Res );
	    else
	      b = Advance( b, &ba, m, inflag == Qin, Q[b], Res );
	  }
	  else /* if ( cross < 0 ) */{
	    if ( aHB > 0)
	      b = Advance( b, &ba, m, inflag == Qin, Q[b], Res );
	    else
	      a = Advance( a, &aa, n, inflag == Pin, P[a], Res );
	  }
#ifdef DEBUG
      printf("%%After advances:a=%d, b=%d; aa=%d, ba=%d; inflag=%d\n", a, b, aa, ba, inflag);
#endif      

   /* Quit when both adv. indices have cycled, or one has cycled twice. */
   } while ( ((aa < n) || (ba < m)) && (aa < 2*n) && (ba < 2*m) );
   
   if ( !FirstPoint ) /* If at least one point output, close up. */
     {
#ifdef DEBUG
       std::cout << "(" << p0[0] << "," << p0[1] << ")" << std::endl;
#endif
       if(p0[0] != (Res->getLast())[0] || p0[1] != (Res->getLast())[1])
	 Res->addPoint(p0);
     }
   
   if(inflag !=Unknown)
     return 1;
   else
   /* Deal with special cases: not implemented. (O'Rourke) */
     /* Completed by I. Sivignon (2013) */
     //if ( inflag == Unknown) 
     {
#ifdef DEBUG
       printf("%%The boundaries of P and Q do not cross.\n");
#endif 
       // Test if Q in included in P
       a = 0; b=0; aa =0;
       a1 = (a + n - 1) % n; // compute point a-1
       bool bIn = true;
       //Test is Q[0] is inside P 
       while (aa<n)
	 {
	   bHA   = AreaSign( P.at(a1), P.at(a), Q.at(b) );
	   bIn = bIn && (bHA>=0);
	   aa++;
	   a1 = a;
	   a = (a+1)%n;
	 }
       if(bIn)
	 {
	   *Res = other;
#ifdef DEBUG
	   std::cout << "Q in contained in P. The intersection is equal to Q." << std::endl;
#endif
	   return 1;
	 }
       
       // Test if P in included in Q
       b = 0; b=a; ba =0;
       b1 = (b + m - 1) % m; // compute point b-1
       bool aIn = true;
       //Test if P[0] is inside Q
       while (ba<m)
	 {
	   aHB   = AreaSign( Q[b1], Q[b], P[a] );
	   aIn = aIn && (aHB>=0);
	   ba++;
	   b1=b;
	   b = (b+1)%m;
	 }
       if(aIn)
	 {
	   *Res = *this;
#ifdef DEBUG
	   std::cout << "P in contained in Q. The intersection is equal to P." << std::endl;
#endif
	   return 1;
	 }
      
#ifdef DEBUG 
       std::cout << "The polygons are disjoint. The intersection is empty." << std::endl;
#endif     
       return 0;
       
       
     }
}


/*---------------------------------------------------------------------
Prints out the double point of intersection, and toggles in/out flag.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate>::InFlag DGtal::Polygon<TCoordinate>::InOut( Point p, InFlag inflag, int aHB, int bHA,Polygon *Res )
{
  
#ifdef DEBUG
  std::cout << "(" << p[0] << " " << p[1] << ")" << std::endl;
#endif
  if(p[0] != (Res->getLast())[0] || p[1] != (Res->getLast())[1])
    Res->addPoint(p);
  /* Update inflag. */
  if      ( aHB > 0)
    return Pin;
  else if ( bHA > 0)
    return Qin;
  else    /* Keep status quo. */
    return inflag;
}






/*---------------------------------------------------------------------
   Advances and prints out an inside vertex if appropriate.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
int  DGtal::Polygon<TCoordinate>::Advance( int a, int *aa, int n, bool inside, Point v, Polygon *Res )
{
  if ( inside )
    {
#ifdef DEBUG
      std::cout << "(" << v[0] << "," << v[1] << ")" << std::endl;
#endif
      if(v[0] != (Res->getLast())[0] || v[1] != (Res->getLast())[1])
	Res->addPoint(v);
    }
  (*aa)++;
  return  (a+1) % n;
}


/*
   Returns true iff c is strictly to the left of the directed
   line through a to b.
*/
template <typename TCoordinate>
inline
bool    DGtal::Polygon<TCoordinate>::Left( Point a, Point b, Point c )
{
        return  AreaSign( a, b, c ) > 0;
}


template <typename TCoordinate>
inline
bool    DGtal::Polygon<TCoordinate>::LeftOn( Point a, Point b, Point c )
{
        return  AreaSign( a, b, c ) >= 0;
}

template <typename TCoordinate>
inline
bool DGtal::Polygon<TCoordinate>::Collinear( Point a, Point b, Point c )
{
        return  AreaSign( a, b, c ) == 0;
}


/*---------------------------------------------------------------------
a - b ==> c.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate>::Point DGtal::Polygon<TCoordinate>::SubVec( Point a, Point b)
{
   int i;
   Point c;

   for( i = 0; i < 2; i++ )
     { 
       c.push_back(a[i] - b[i]);
     }
#ifdef DEBUG
   std::cout << c[0] << " " << c[1] << std::endl;
#endif
   return c;
   
}

template <typename TCoordinate>
inline
int	DGtal::Polygon<TCoordinate>::AreaSign( Point a, Point b, Point c )
{
  Coordinate area2;
  
  area2 = ( b[0] - a[0] ) * ( c[1] - a[1] ) -
    ( c[0] - a[0] ) * ( b[1] - a[1] );
  
#ifdef DEBUG
  //std::cout << area2.numerator() << std::endl;
#endif
  
  /* The area should be an integer. */
  if(area2==0) return 0;
  else if      ( area2 >  0 ) return  1;
    else if ( area2 < 0 ) return -1;
  //else                     return  0;
}


/*---------------------------------------------------------------------
O'Rourke (1997)
SegSegInt: Finds the point of intersection p between two closed
segments ab and cd.  Returns p and a char with the following meaning:
    'e': The segments collinearly overlap, sharing a point.
   'v': An endpoint (vertex) of one segment is on the other segment,
        but 'e' doesn't hold.
   '1': The segments intersect properly (i.e., they share a point and
        neither 'v' nor 'e' holds).
   '0': The segments do not intersect (i.e., they share no points).
Note that two collinear segments that share just one point, an endpoint
of each, returns 'e' rather than 'v' as one might expect.
---------------------------------------------------------------------*/

template <typename TCoordinate>
inline
char	DGtal::Polygon<TCoordinate>::SegSegInt( Point a, Point b, Point c, Point d, Point *p, Point *q )
{
   Coordinate  s, t;       /* The two parameters of the parametric eqns. */
   //double num, denom;  /* Numerator and denoninator of equations. */
   Coordinate num, denom;
   char code = '?';    /* Return char characterizing intersection. */
   (*p).clear();
   
#ifdef DEBUG
   std::cout << "%%SegSegInt: a,b,c,d: " << "(" << a[0] << " " << a[1] << ")("<<  b[0] << " " << b[1] << ")(" <<  c[0] << " " << c[1] << ")(" << d[0] << " " << d[1] << ")" << std::endl;
#endif
   denom = a[0] * ( d[1] - c[1] ) +
     b[0] * ( c[1] - d[1] ) +
     d[0] * ( b[1] - a[1] ) +
     c[0] * ( a[1] - b[1] );
   
   /* If denom is zero, then segments are parallel: handle separately. */
   if (denom == 0)
     return  ParallelInt(a, b, c, d, p, q);
   
   num =    a[0] * ( d[1] - c[1] ) +
     c[0] * ( a[1] - d[1] ) +
     d[0] * ( c[1] - a[1] );
   if ( (num == 0) || (num == denom) ) code = 'v';
   s = num/denom;
   /*printf("num=%lf, denom=%lf, s=%lf\n", num, denom, s);*/
#ifdef DEBUG
   std::cout << s << std::endl;
#endif
   
   num = -( a[0] * ( c[1] - b[1] ) +
            b[0] * ( a[1] - c[1] ) +
            c[0] * ( b[1] - a[1] ) );
   if ( (num == 0) || (num == denom) ) code = 'v';
   t = num / denom;
   /*printf("num=%lf, denom=%lf, t=%lf\n", num, denom, t);*/
#ifdef DEBUG
   std::cout << t << std::endl;
#endif

   
   if      ( (0 < s) && (s < 1) &&
             (0 < t) && (t < 1) )
     code = '1';
   else if ( (0 > s) || (s > 1) ||
             (0 > t) || (t > 1) )
     code = '0';
   
   (*p).push_back(a[0] + s * ( b[0] - a[0] ));
   (*p).push_back(a[1] + s * ( b[1] - a[1] ));
   
#ifdef DEBUG
   std::cout << "(" << (*p)[0] << "," << (*p)[1] << ")" << std::endl;
#endif 

   return code;
}

template <typename TCoordinate>
inline
char   DGtal::Polygon<TCoordinate>::ParallelInt( Point a, Point b, Point c, Point d, Point *p, Point *q )
{
  if ( !Collinear( a, b, c) )
      return '0';

   if ( Between( a, b, c ) && Between( a, b, d ) ) {
     *p = c;
     *q = d;
     return 'e';
   }
   if ( Between( c, d, a ) && Between( c, d, b ) ) {
     *p = a;
     *q = b;
     return 'e';
   }
   if ( Between( a, b, c ) && Between( c, d, b ) ) {
     *p = c;
     *q = b;
     return 'e';
   }
   if ( Between( a, b, c ) && Between( c, d, a ) ) {
     *p = c;
     *q = a;
     return 'e';
   }
   if ( Between( a, b, d ) && Between( c, d, b ) ) {
     *p = d;
     *q = b;
     return 'e';
   }
   if ( Between( a, b, d ) && Between( c, d, a ) ) {
     *p = d;
     *q = a;
     return 'e';
   }
   return '0';
}



/*---------------------------------------------------------------------
Returns TRUE iff point c lies on the closed segement ab.
Assumes it is already known that abc are collinear.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
bool    DGtal::Polygon<TCoordinate>::Between( Point a, Point b, Point c )
{
   Point      ba, ca;

   /* If ab not vertical, check betweenness on x; else on y. */
   if ( a[0] != b[0] )
      return ((a[0] <= c[0]) && (c[0] <= b[0])) ||
             ((a[0] >= c[0]) && (c[0] >= b[0]));
   else
      return ((a[1] <= c[1]) && (c[1] <= b[1])) ||
             ((a[1] >= c[1]) && (c[1] >= b[1]));
}


/*---------------------------------------------------------------------
Returns the dot product of the two input vectors.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate>::Coordinate  DGtal::Polygon<TCoordinate>::Dot( Point a, Point b )
{
  int i;
  Coordinate sum = 0;
  
  for( i = 0; i < 2; i++ )
    sum = sum + a[i] * b[i];
  
  return  sum;
}


template <typename TCoordinate>
inline
void	DGtal::Polygon<TCoordinate>::PrintSharedSeg( Point p, Point q, Polygon *Res )
{
#ifdef DEBUG
  std::cout << "(" << p[0] << "," << p[1] << ")" << std::endl;
  std::cout << "(" << q[0] << "," << q[1] << ")" << std::endl;
#endif
  Res->addPoint(p);
  Res->addPoint(q);

}




/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */

template <typename TCoordinate>
inline
void
DGtal::Polygon<TCoordinate>::selfDisplay ( std::ostream & out)
{
  
  out << "[Polygon]" <<  endl;
  
  Iterator it;
  
  for(it = myPoints.begin();it != myPoints.end();it++)
    {
      Point p = *it;
      out << "(" << p[0] << "," << p[1] << ")" << endl;
    }
  out << "[End Polygon]" <<  endl;
}


int forwardEdge(int i)
{
  if(i==0 || i==1 || i==4 || i==5)
    return 1;
  else
    if(i==2 || i==3 || i==6 || i==7)
      return -1;
    else
      std::cerr << "Error: this does not work for random polygons. Polygons must be preimage-like (4 vertices, etc)" << std::endl;
}



/*---------------------------------------------------------------------
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
bool  DGtal::Polygon<TCoordinate>::convexIntersectWithoutComputation(const Polygon & other, vector<int> *res )
/* P(=this) has n vertices, Q(=other) has m vertices. */
{
   int     a, b;           /* indices on P and Q (resp.) */
   int     a1, b1;         /* a+1, b+1 (resp.) */
   Point A, B;           /* directed edges on P and Q (resp.) */
   int     cross;          /* sign of z-component of A x B */
   int     bHA, aHB;       /* b in H(A); a in H(b). */
   Point Origin = Point(2,0); /* (0,0) */
   Point p;              /* double point of intersection */
   Point q;              /* second point of intersection */
   InFlag inflag;         /* {Pin, Qin, Unknown}: which inside */
   int     aa, ba;         /* # advances on a & b indices (after 1st inter.) (counters)*/
   bool    FirstPoint;     /* Is this the first point? (used to initialize).*/
   Point p0;             /* The first point. */
   char     code;           /* SegSegTest return code. */ 

   PointList P=myPoints;
   PointList Q=other.myPoints;


   int n = P.size();
   int m = Q.size();
   
   
  
     /* Initialize variables. */
     a = 0; b = 0; aa = 0; ba = 0;
   inflag = Unknown; FirstPoint = true;
   
   do {
     
     /* Computations of key variables. */
     a1 = (a + 1) % n; // compute point a+1
     b1 = (b + 1) % m; // compute point b+1
     
     

#ifdef DEBUG
     std::cout << "loop: a = " << a << " b = " << b << std::endl;
     std::cout << "A = ";
#endif
     A = SubVec( P[a1], P[a]); // compute vector A = aa1
#ifdef DEBUG
     std::cout << "B = ";
#endif
     B = SubVec( Q[b1], Q[b]); // compute vector B = bb1
     
     cross = AreaSign( Origin, A, B );
     aHB   = AreaSign( Q.at(b), Q.at(b1), P.at(a1) ); // compute position of a wrt halfplane defined by B
     bHA   = AreaSign( P.at(a), P.at(a1), Q.at(b1) ); // compute position of b wrt halfplane defined by A
#ifdef DEBUG
     printf("%%cross=%d, aHB=%d, bHA=%d\n", cross, aHB, bHA );
#endif
     /* If A & B intersect, update inflag. */
     code = SegSegTest(P[a], P[a1], Q[b], Q[b1]);
#ifdef DEBUG 
     printf("%%SegSegTest: code = %c\n", code );
#endif     
     
     // If the segments intersect, initialisation and update inflag
     if(code == '1' || code == 'v' || code == 'w')
       {
	 if ( inflag == Unknown && FirstPoint ) 
	   {
	     aa = ba = 0;
	     FirstPoint = false;
	   }
	 
	 inflag = InOutWithoutComputation(inflag, aHB, bHA);
       }
     
     if(code=='1' || code == 'v') // the edge with origin a and the one with origin b intersect
       {
	 //recall that the edges intersect if they are both forward or both backward
	 if(forwardEdge(a)*forwardEdge(b+n)==1)
	   {
#ifdef DEBUG
	     std::cout << "Add point " << a << " " << b+n << std::endl;
#endif 
	     res->push_back(a); // Edges from P are numbered from 0 to n-1
	     res->push_back(b+n); // Edges from Q are numbered from n to n+m-1	 
	   }
       }
     
     if(code=='w') // the edges share an extremity
       {
	 std::cout << "segments share an extremity" << std::endl;
	 
	 // the only case when the intersection should be reported is
	 // when the common extremity is the origin of both edges  
	 if(P[a]==Q[b])
	   {
	     std::cout << "inflag = " << inflag << std::endl;
	     if(inflag == Unknown)
	       if(cross < 0)
		 inflag = Qin;
	       else
		 if(cross > 0)
		   inflag = Pin;
	     std::cout << "inflag = " << inflag << std::endl;
	     if(cross < 0)
	       {
		 if(inflag == Pin && forwardEdge(a)*forwardEdge(a-1)==1)
		   {
		     res->push_back(a-1);
		     res->push_back(a);
		   }
		 else
		   if(inflag == Qin && forwardEdge(b-1+n)*forwardEdge(a)==1)
		     {
		       res->push_back(b-1+n);
		       res->push_back(a);
		     } 
	       }
	     if(cross > 0)
	       {
		 if(inflag == Pin && forwardEdge(b+n)*forwardEdge(a-1)==1)
		   {
		     res->push_back(a-1);
		     res->push_back(b+n);
		   }
		 else
		   if(inflag == Qin && forwardEdge(b-1+n)*forwardEdge(b+n)==1)
		     {
		       res->push_back(b-1+n);
		       res->push_back(b+n);
		     } 
	       }    
	   }
       }
     
     /*-----Advance rules-----*/
     
     /* Special case: A & B overlap (collinear and share a point) and oppositely oriented. */
     if ( ( code == 'e' ) && (Dot( A, B ) < 0) )
       { 
	 res->push_back(a);
	 res->push_back(b+n);
	 exit(EXIT_SUCCESS);
       }
     
     /* Special case: A & B parallel and separated. */
     if ( (cross == 0) && ( aHB < 0) && ( bHA < 0 ) )
       printf("%%P and Q are disjoint.\n"), exit(EXIT_SUCCESS);
      
      else 
	/* Special case: A & B collinear. */
	if ( (cross == 0) && ( aHB == 0) && ( bHA == 0 ) ) 
	  {
	  /* Advance but do not output point. */
	    if ( inflag == Pin )
	      b = AdvanceWithoutComputation( b, &ba, m, false, b+n, res );
	    else
	      a = AdvanceWithoutComputation( a, &aa, n, false, a, res );
	  }
     
     /* Generic cases. */
	else 
	  if ( cross >= 0 ) {
	    if ( bHA > 0)
	      a = AdvanceWithoutComputation( a, &aa, n, inflag == Pin, a, res );
	    else
	      b = AdvanceWithoutComputation( b, &ba, m, inflag == Qin, b+n, res );
	  }
	  else /* if ( cross < 0 ) */{
	    if ( aHB > 0)
	      b = AdvanceWithoutComputation( b, &ba, m, inflag == Qin, b+n, res );
	    else
	      a = AdvanceWithoutComputation( a, &aa, n, inflag == Pin, a, res );
	  }
#ifdef DEBUG
      printf("%%After advances:a=%d, b=%d; aa=%d, ba=%d; inflag=%d\n", a, b, aa, ba, inflag);
#endif      

   /* Quit when both adv. indices have cycled, or one has cycled twice. */
   } while ( ((aa < n) || (ba < m)) && (aa < 2*n) && (ba < 2*m) );
   
   
   if(inflag !=Unknown)
     return 1;
   else
   /* Deal with special cases: not implemented. (O'Rourke) */
     /* Completed by I. Sivignon (2013) */
     //if ( inflag == Unknown) 
     {
#ifdef DEBUG
       printf("%%The boundaries of P and Q do not cross.\n");
#endif 
       // Test if Q in included in P
       a = 0; b=0; aa =0;
       a1 = (a + 1) % n; // compute point a-1
       bool bIn = true;
       //Test is Q[0] is inside P 
       while (aa<n)
	 {
	   bHA   = AreaSign( P.at(a), P.at(a1), Q.at(b) );
	   bIn = bIn && (bHA>=0);
	   aa++;
	   a = a1;
	   a1 = (a+1)%n;
	 }
       if(bIn)
	 {
	   // res = Q
	   res->push_back(n);
	   for(int i=1;i<m;i++)
	     {
	       res->push_back(i+n);
	       res->push_back(i+n);
	     }
	   res->push_back(n);
#ifdef DEBUG
	   std::cout << "Q in contained in P. The intersection is equal to Q." << std::endl;
#endif
	   return 1;
	 }
       
       // Test if P in included in Q
       b = 0; b=a; ba =0;
       b1 = (b + 1) % m; // compute point b-1
       bool aIn = true;
       //Test if P[0] is inside Q
       while (ba<m)
	 {
	   aHB   = AreaSign( Q[b1], Q[b], P[a] );
	   aIn = aIn && (aHB>=0);
	   ba++;
	   b=b1;
	   b1 = (b+1)%m;
	 }
       if(aIn)
	 {
	   // res = P
	   res->push_back(0);
	   for(int i=1;i<n;i++)
	     {
	       res->push_back(i);
	       res->push_back(i);
	     }
	   res->push_back(0);
#ifdef DEBUG
	   std::cout << "P in contained in Q. The intersection is equal to P." << std::endl;
#endif
	   return 1;
	 }
      
#ifdef DEBUG 
       std::cout << "The polygons are disjoint. The intersection is empty." << std::endl;
#endif     
       return 0;
       
       
     }
}


/*---------------------------------------------------------------------
Prints out the double point of intersection, and toggles in/out flag.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
typename DGtal::Polygon<TCoordinate>::InFlag DGtal::Polygon<TCoordinate>::InOutWithoutComputation(InFlag inflag, int aHB, int bHA)
{
  /* Update inflag. */
  if      ( aHB > 0)
    return Pin;
  else if ( bHA > 0)
    return Qin;
  else    /* Keep status quo. */
    return inflag;
}



/*---------------------------------------------------------------------
Test whether the two segments intersect or not. Does not compute the intersection point. 
   'e': The segments collinearly overlap, sharing a point.
   'v': An endpoint (vertex) of one segment is on the other segment,
        but 'e' doesn't hold.
   '1': The segments intersect properly (i.e., they share a point and
        neither 'v' nor 'e' holds).
   '0': The segments do not intersect (i.e., they share no points).
   'w': The two segments share exactly one extremity.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
char DGtal::Polygon<TCoordinate>::SegSegTest(Point a, Point b, Point c, Point d)
{
  int cAB = AreaSign(a,b,c);
  int dAB = AreaSign(a,b,d);
  int aCD = AreaSign(c,d,a);
  int bCD = AreaSign(c,d,b);

  if(cAB*dAB == -1 && aCD*bCD == -1)
    return '1'; 
  else
    if(cAB*dAB  == 1 || aCD*bCD == 1)
      return '0';
    else
      if(cAB*dAB == -1 || aCD*bCD == -1)
	return 'v';
      else // cAB*dAB == 0 && aCD*bCD == 0
	if(aCD == 0 && bCD == 0 && cAB == 0 && dAB ==0)
	  {
	    if(Between(a,b,c) || Between(a,b,d) || Between(c,d,a) || Between(c,d,b))
	      return 'e';
	    else
	      return '0';
	  }
	else // (aCD!=0 || bCD!=0) && (cAB!=0 || dAB!=0)
	  return 'w';
	     
}


/*---------------------------------------------------------------------
   Advances and prints out an inside vertex if appropriate.
---------------------------------------------------------------------*/
template <typename TCoordinate>
inline
int  DGtal::Polygon<TCoordinate>::AdvanceWithoutComputation( int a, int *aa, int n, bool inside, int i, vector<int> *res )
{
  if ( inside )
    {
#ifdef DEBUG
      std::cout << "Advance push " << i << " and " << i+1 << std::endl;
      //std::cout << "(" << v[0] << "," << v[1] << ")" << std::endl;
#endif
      if(forwardEdge(i)*forwardEdge(i+1)==1)
	{
	  res->push_back(i);
	  res->push_back(i+1);
	}
    }
  (*aa)++;
  return  (a+1) % n;
}
